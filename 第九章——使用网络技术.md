文字颜色

```
<font color=red>内容</font>
```

<font color=red>内容</font>

文字与代码

```
<mark>highlight 2</mark>
```code 1```
`code 2`
==4==
```

<mark>highlight 2</mark>
```code 1```
`code 2`

==4==

## 第九章——使用网络技术

### 9.1 WebView的用法

创建Web Test项目

1.首先在activitymain.xml文件中加入如下代码:

```java
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
        
------------------------------------------
<WebView
    android:id="@+id/web_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/>
-------------------------------------------
        
</androidx.constraintlayout.widget.ConstraintLayout>
```

2.修改MainActivity中的代码 

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        WebView webView = (WebView) findViewById(R.id.web_view);
        webView.getSettings().setJavaScriptEnabled(true);
        webView.setWebViewClient(new WebViewClient());
        webView.loadUrl("http://www.baidu.com");
    }
}
```

webView.getSettings()可以用来设置浏览器的属性，而setJavaScriptEnabled()方法表示让WebView支持JavaScript脚本。

调用webView.setWebViewClient方法，并传入了一个WebViewClient的实例。这段代码的作用是，当需要从一个网页跳转到另一个网页时，使目标网页仍然在当前WebView中显示，而不是打开系统浏览器。

最后调用WebView的loadUrl()方法，并将需要展示的网页的网址传入，即可展示相应网页的内容

> 注意：由于打开网页使用到了联网功能，所以需要申请网络权限

```java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
        
    <uses-permission android:name="android.permission.INTERNET" />//申请权限
.........
</manifest>
```

### 9.2　使用HTTP协议访问网络

#### **9.2.1　使用HttpURLConnection**

##### 一、HttpURLConnection的基本用法

**1、步骤1：获得HttpURLConnection类的实例**

> 由于HttpURLConnection类是一个抽象类，丌能直接实例化对象，因此需要使用 URL的openConnection()方法创建具体的实例。
>
> 1.使用new关键字创建一个URL对象，并传入目标的网络地址
>
> URL url = new URL(“https://www.baidu.com”);
>
> 2.调用openConnection()方法，创建HttpURLConnection类的实例
>
> HttpURLConnection connection = (HttpURLConnection)url.openConection();

**2、步骤2：设置HTTP请求参数**

| **函数**             | **说明**                                                     |
| -------------------- | ------------------------------------------------------------ |
| setRequestMethod()   | 设置请求参数，主要有两种方式：GET请求、POST请求              |
| setConnectTimeOut()  | 设置连接超时时间                                             |
| setReadTimeOut()     | 设置读取超时时间                                             |
| setRequestProperty() | 设置请求头参数，主要是添加HTTP请求HEAD中的一些参数           |
| setDoOutput()        | 设置是否向HttpURLConnection输出，对于POST请求，参数要放在 http正文中，因此需要设为true，默认情冴下为false |
| setDoInput()         | 设置是否从HttpURLConnection读入，默认情冴下为true            |


 **3、步骤3：调用connect()连接进程资源**

**connection.connect();**

| 函数                 | 说明                 |
| -------------------- | -------------------- |
| getResponseCode()    | 获取服务器的响应代码 |
| getResponseMessage() | 获取服务器的响应消息 |

<mark>注意：往往在读取数据前，需要查询数据的响应结果。</mark>

```java
int responseCode = connection.getResponseCode();
	if(responseCode == HttpURLConnection.HTTP_OK)
    	{
    		读取数据的操作
    	}
```

**4、步骤4：利用getInputStream()访问资源（GET请求）**

> 使用getInputStream()方法只是得到一个流对象，并丌是数据，丌过我们可以从流 中读出数据。
>
> <font color=red>**注意 从这个流对象中只能读取一次数据，第二次读取时将会得到空数据。**</font>
>
> <img src="https://img-blog.csdnimg.cn/20210909232937202.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Yqg5bee5p6r5pmv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:80%;" />

**步骤4：利用getOutputStream()传输POST消息（POST请求）**

>  使用getOutputStream()方法用来传输POST消息，该方法得到的是一个输出流，该 输出流中保存的是发送给服务器端的数据。
>
>  <font color=red>**注意 connection.setDoOutput(true); //允许写出**</font>
>
>  <img src="https://img-blog.csdnimg.cn/20210909233102160.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Yqg5bee5p6r5pmv,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:80%;" />



**5、步骤5：关闭HttpURLConnection连接**

> 所有的操作全部完成后，就可以调用disconnect()方法将这个HTTP连接关闭掉。
>
> ```java
> if(connection != null)                                                                        
> 	connection.disconnect();
> ```
>
> <font color=red>**注意**</font>
>
> <font color=red>**（1）声明网络权限：**</font>
>
> <font color=red>**（2）网络请求，需要单独开辟一个子线程，然后等到数据返回成功后回到 主线程迚行UI操作。**</font>



##### 二、代码部分

```java
public class MainActivity extends AppCompatActivity {

    private      TextView textView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //对象和布局文件上的控件进行绑定
        textView = findViewById(R.id.tv);

        //定义一个匿名的子线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                //抓取百度首页的数据
                HttpURLConnection connection =null;
                try{
                    //1.获取HttpURLConnection类的实例
                    URL url = new URL("https://www.baidu.com");
                    connection = (HttpURLConnection) url.openConnection();
                    //2.设置HTTP请求的参数
                    connection.setRequestMethod("GET"); //设置请求方式为GET
                    connection.setConnectTimeout(8000);  //设置连接超时为8s
                    connection.setReadTimeout(8000);    //设置读取操作超时为8s
                    //3.调用connect()方法连接远程资源，并对服务器响应进行判断
                    connection.connect();
                    int responseCode = connection.getResponseCode();
                    if(responseCode == HttpURLConnection.HTTP_OK){
                        //进行数据读取的操作
                        //4.利用getInputStream()方法访问资源
                        //4.1 通过getInputStream()方法获取响应流
                        InputStream in = connection.getInputStream();
                        //4.2 构建BufferedReader对象
                        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                        //4.3 构建字符串对象，接受缓冲流中的数据
                        StringBuilder sb = new StringBuilder();
                        String line =null;
                        while ((line=reader.readLine())!=null){
                            sb.append(line);
                        }
                        //4.4 将服务器返回的数据显示到TextView控件上
                        // textView.setText(sb.toString());    //写法是错误的
                        showResponse(sb.toString());
                    }

                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    if(connection != null){
                        connection.disconnect();
                    }
                }

            }
        }).start();
    }

    private void showResponse(final String response) {
        //将服务器返回的数据回到UI线程，从而在TextView控件进行显示
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                //在这里进行UI操作，将结果显示到界面上
                textView.setText(response);
            }
        });

    }
}

```

> 如果想要提交数据给服务器，只需要将HTTP请求的方法改成POST ，并在获取输入流之前把要提交的数据写出即可。<u>注意每条数据都要以键值对的形式存在，数据与数据之间用“&”符号隔开</u>，比如说我们想要向服务器提交用户名和密码，就可以这样写：

```java
connection.setRequestMethod("POST");
DataOutputStream out = new DataOutputStream(connection.getOutputStream());
out.writeBytes("username=admin&password=123456");//"键=值&键=值"
```

#### 9.2.2　使用OkHttp

> 简介：Okhttp是由移动支付Square公司贡献，用于替代HttpUrlConnection和[Apache](https://so.csdn.net/so/search?q=Apache&spm=1001.2101.3001.7020) HttpClient(android API23 6.0里已移除HttpClient)的网络框架。[官方文档](https://square.github.io/okhttp/)

##### 一、基本用法

**1.添加依赖**

```java
implementation("com.squareup.okhttp3:okhttp:4.10.0")
```

**2.创建一个OkHttpClient的实例**

```java
OkHttpClient client = new OkHttpClient();
```

**3.创建一个`Request` 对象,发起一条HTTP请求**

```java
Request request = new Request.Builder().build();
```

**4.丰富`Request` 对象,通过`url()` 方法来设置目标的网络**

```java
Request request = new Request.Builder()
        .url("http://www.baidu.com")
        .build();
```

**5.创建一个`Call` 对象，并调用它的`execute()` 方法来发送请求并获取服务器返回的数据**

```java
Response response = client.newCall(request).execute();
```

**6.获得返回数据response的具体内容**

```java
String responseData = response.body().string();
```

> **发起`POST` 请求的方法**
>
> 1.构建出一个`Request Body` 对象来存放待提交的参数
>
> ```java
> RequestBody requestBody = new FormBody.Builder()
>      .add("username", "admin")
>      .add("password", "123456")
>      .build();
> ```
>
> 2.在Request.Builder中调用一下`post()` 方法，并将`RequestBody` 对象传入
>
> ```java
> Request request = new Request.Builder()
>      .url("http://www.baidu.com")
>      .post(requestBody)
>      .build();
> ```
>
> 接下来的操作就和`GET` 请求一样了，调用`execute()` 方法来发送请求并获取服务器返回的数据即可。

使用OkHttp实现上一个项目，修改MainActivity中内容：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    ...

    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.send_request) {
            sendRequestWithOkHttp();
        }
    }

    private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            .url("http://www.baidu.com")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    showResponse(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    ...
}
```

### 9.3　解析JSON格式数据

> 通常情况下，每个需要访问网络的应用程序都会有一个自己的服务器，我们可以向服务 器提交数据，也可以从服务器上获取数据。不过这个时候就出现了一个问题，这些数据到底 要以什么样的格式在网络上传输呢？
> 在网络上传输数据时最常用的格式有两种，[XML](https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020)和 JSON，比起XML，JSON的主要优势在于它的体积更小，在网络上传输的时候可以更省流量。但缺点在于，它的语义性较差，看起来不如XML直观。这里先学习JSON。
>
> Json数据主要分为对象、数组、键值对。
>
> ```java
> {“result_num”:5,“result”:[{“score”:0.6854481,“name”:“金南瓜”},{“score”:0.3145323,“name”:“南瓜”}],“log_id”:1532360688868669332}
> ```
>
> {}表示一个对象，[]表示数组，“name”:5 表示键值对（数据），前面name 表示标识，后面5是值，值可以是int、char、string等类型。“：”冒号用于分隔数据的“名”和“值”，对象和数组可以互相包含，但是对象不可以直接包含对象也不可以直接包含数组，数组不能直接存放数据（键值对）。

**1.首先要搭建一个最简单的 Web服务器，可参考以下文章：**

[Apache服务器的下载与安装](http://blog.csdn.net/u010356768/article/details/78579540)

**2.在D:\Apache\Apache24\htdocs目录中新建一个get_data.json的文件，然后编辑这个文件，并加入如下JSON格式的内容：**

```java
[{"id":"5","version":"5.5","name":"Clash of Clans"},
{"id":"6","version":"7.0","name":"Boom Beach"},
{"id":"7","version":"3.5","name":"Clash Royale"}]
```

这时在浏览器中访问http://127.0.0.1/get_data.json 这个网址，就会出现以上内容

#### 9.3.1　使用JSONObject

> 解析JSON数据也有很多种方法，可以使用官方提供的JSONObject，也可以使用谷歌的开源库GSON。另外，一些第三方的开源库如Jackson、FastJSON等也非常不错。

修改MainActivity中的代码，如下所示:

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    ...

    private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            // 指定访问的服务器地址是电脑本机
                            .url("http://10.0.2.2/get_data.json")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    parseJSONWithJSONObject(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    ...

    private void parseJSONWithJSONObject(String jsonData) {
        try {
            JSONArray jsonArray = new JSONArray(jsonData);
            for (int i = 0; i < jsonArray.length(); i++) {
                JSONObject jsonObject = jsonArray.getJSONObject(i);
                String id = jsonObject.getString("id");//
                String name = jsonObject.getString("name");
                String version = jsonObject.getString("version");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```

> ==注意：不能直接访问第二级的键值对。==
>
> ```java
> //String re = jsonObject.getString("name");  
> //这样直接获取是错误的，因为该对象中没有直接的“name”这个标志对应的值数据，只有“result”这个标志对应值的数组对象中有“name”这个标志，但是不能直接访问获取。
> ```

+ **获取数组**

```java
String result = {"result_num":5,"result":[{"score":0.6854481,"name":"金南瓜"},{"score":0.3145323,"name":"南瓜"}],"log_id":1532360688868669332}
 JSONObject jsonObject = new JSONObject(result);
JSONArray jsonArray = jsonObject.getJSONArray("result");
//得到的即为"result"对应的数组值
//内容：[{"score":0.6854481,"name":"金南瓜"},{"score":0.3145323,"name":"南瓜"}]
//显然这是一个json数组类型。
```

+ **获取数组中对象**

```java
 JSONObject js0 = jsonArray.getJSONObject(0)；// {"score":0.6854481,"name":"金南瓜"}
 JSONObject js1 = jsonArray.getJSONObject(1)；// {"score":0.3145323,"name":"南瓜"}
```

+ **补充**

+ json数据解析也支持**链式编程**。

  ```java
   String re= jsonArray.getJSONObject(0).getString("name");// 金南瓜
  ```

#### 9.3.2　使用GSON

> Gson是目前功能最强的JSON解析器，并且不需要依赖额外jar包，能够直接运行在java平台。与另一款优秀的JSON解析器[FastJson](https://so.csdn.net/so/search?q=FastJson&spm=1001.2101.3001.7020)相比Gson的优势是可以准确顺利的转换复杂Bean，而FastJson对一些复杂Bean的转换就会出现一些问题。

**一、基本语法**

GSON库可以将一段JSON格式的字符串自动映射成一个对象，从而不需要我们再手动去编写代码进行解析。

比如说一段JSON格式的数据如下所示：

```java
{"name":"Tom","age":20}
```

那我们就可以定义一个`Person` 类，并加入`name` 和`age` 这两个字段，然后只需简单地调用如下代码就可以将JSON数据自动解析成一个`Person` 对象了：

```java
Gson gson = new Gson();
Person person = gson.fromJson(jsonData, Person.class);
```

如果需要解析的是一段JSON数组会稍微麻烦一点，我们需要借助TypeToken将期望解析成的数据类型传入到`fromJson()` 方法中，如下所示：

```java
List<Person> people = gson.fromJson(jsonData, new TypeToken<List<Person>>() {}.getType());
```

**二、使用**

**1.导入依赖**

```java
implementation 'com.google.code.gson:gson:2.8.6'
```

**2.新增一个`App` 类，并加入`id` 、`name` 和`version` 这3个字段，如下所示：**

```java
public class App {

    private String id;

    private String name;

    private String version;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

}
```

3.然后修改MainActivity中的代码：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    ...

    private void sendRequestWithOkHttp() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                    Request request = new Request.Builder()
                            // 指定访问的服务器地址是电脑本机
                            .url("http://10.0.2.2/get_data.json")
                            .build();
                    Response response = client.newCall(request).execute();
                    String responseData = response.body().string();
                    parseJSONWithGSON(responseData);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

    ...

    private void parseJSONWithGSON(String jsonData) {
        Gson gson = new Gson();
        List<App> appList = gson.fromJson(jsonData, new TypeToken<List<App>>()
            {}.getType());
        for (App app : appList) {
            Log.d("MainActivity", "id is " + app.getId());
            Log.d("MainActivity", "name is " + app.getName());
            Log.d("MainActivity", "version is " + app.getVersion());
        }
    }

}
```

## 第十章——Socket

#### 10.1什么是socket?

​        Socket的英文原义是“孔”或“插座”。在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。

        Socket套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
        Socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

#### 10.2 Socket的原理

 Socket实质上提供了进程通信的端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互通信的。正如打电话之前，双方必须各自拥有一台电话机一样。

```JAVA
    套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。
    1、服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。
    2、客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
    3、连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
```

#### 10.3 基于java的socket网络编程实现

> Server端Listen监听某个端口是否有连接请求，Client端向Server 端发出连接请求，Server端向Client端发回Accept接受消息。这样一个连接就建立起来了。Server端和Client端都可以通过Send，Write等方法与对方通信。

对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤： 

1、创建Socket；

2、 打开连接到Socket的输入/出流；

3、按照一定的协议对Socket进行读/写操作；

4、关闭Socket。

#### 10.4 基于TCP的socket实现

SocketClient.java

```JAVA
public class SocketClient {
	
	public static void main(String[] args) throws InterruptedException {
		try {
			// 和服务器创建连接
			Socket socket = new Socket("localhost",8088);
			
			// 要发送给服务器的信息
			OutputStream os = socket.getOutputStream();
			PrintWriter pw = new PrintWriter(os);
			pw.write("客户端发送信息");
			pw.flush();
			
			socket.shutdownOutput();
			
			// 从服务器接收的信息
			InputStream is = socket.getInputStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			String info = null;
			while((info = br.readLine())!=null){
				System.out.println("我是客户端，服务器返回信息："+info);
			}
			
			br.close();
			is.close();
			os.close();
			pw.close();
			socket.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
 
}
```

SocketServer.java

```JAVA
public class SocketServer {
	
	public static void main(String[] args) {
		try {
			// 创建服务端socket
			ServerSocket serverSocket = new ServerSocket(8088);
			
			// 创建客户端socket
			Socket socket = new Socket();	
			
			//循环监听等待客户端的连接
            while(true){
            	// 监听客户端
            	socket = serverSocket.accept();
            	
            	ServerThread thread = new ServerThread(socket);
            	thread.start();
            	
            	InetAddress address=socket.getInetAddress();
                System.out.println("当前客户端的IP："+address.getHostAddress());
            }
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
	}
 
}
```

ServerThread.java

```JAVA
public class ServerThread extends Thread{
	
	private Socket socket = null;
	
	public ServerThread(Socket socket) {
		this.socket = socket;
	}
 
	@Override
	public void run() {
		InputStream is=null;
        InputStreamReader isr=null;
        BufferedReader br=null;
        OutputStream os=null;
        PrintWriter pw=null;
        try {
			is = socket.getInputStream();
			isr = new InputStreamReader(is);
			br = new BufferedReader(isr);
			
			String info = null;
			
			while((info=br.readLine())!=null){
				System.out.println("我是服务器，客户端说："+info);
			}
			socket.shutdownInput();
			
			os = socket.getOutputStream();
			pw = new PrintWriter(os);
			pw.write("服务器欢迎你");
			
			pw.flush();
        } catch (Exception e) {
			// TODO: handle exception
		} finally{
			//关闭资源
            try {
                if(pw!=null)
                    pw.close();
                if(os!=null)
                    os.close();
                if(br!=null)
                    br.close();
                if(isr!=null)
                    isr.close();
                if(is!=null)
                    is.close();
                if(socket!=null)
                    socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
		}
	}
 
}
```

#### 10.5 基于UDP的socket实现

SocketClient.java

```JAVA
public class SocketClient {
	
	public static void main(String[] args) {
		try {
            // 要发送的消息
            String sendMsg = "客户端发送的消息";
            
            // 获取服务器的地址
            InetAddress addr = InetAddress.getByName("localhost");
            
            // 创建packet包对象，封装要发送的包数据和服务器地址和端口号
            DatagramPacket packet = new DatagramPacket(sendMsg.getBytes(),
            		sendMsg.getBytes().length, addr, 8088); 
            
            // 创建Socket对象
            DatagramSocket socket = new DatagramSocket();
            
            // 发送消息到服务器
            socket.send(packet);
 
            // 关闭socket
            socket.close();
            
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
	}
}
```

SocketClient.java

```JAVA
public class SocketServer {
	
	public static void main(String[] args) {
		try {
			 // 要接收的报文
			byte[] bytes = new byte[1024];
			DatagramPacket packet = new DatagramPacket(bytes, bytes.length);
			
			// 创建socket并指定端口
			DatagramSocket socket = new DatagramSocket(8088);
			
			// 接收socket客户端发送的数据。如果未收到会一致阻塞
			socket.receive(packet);
			String receiveMsg = new String(packet.getData(),0,packet.getLength());
			System.out.println(packet.getLength());
			System.out.println(receiveMsg);
			
			// 关闭socket
			socket.close();
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
	}
 
}
```

> ​      运行时，先启动SocketServer，再启动SocketClient，会正常打印数据。在先启动SocketServer时，代码执行到socket.receive(packet)时会一致阻塞在这里，直到启动SocketClient后，SocketServer会继续执行，并将收到SocketClient的信息打印出来。如果是先启动SocketClient，会立即执行完毕，再执行SocketServer时，依旧会阻塞在receive方法处，直到下一次SocketClient的执行。

## 第十一章——定位

> 通过百度实现定位

#### 11.1 申请API

登录http://lbsyun.baidu.com/apiconsole/key

![image-20230115160658363](C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230115160658363.png)

点击“创建应用”，之后会出现这个界面

选择"Android SDK"

<img src="C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230115161237950.png" alt="image-20230115161237950" style="zoom: 67%;" />

**SHAI**

1.打开AS的terminal窗口

<img src="C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230115171237388.png" alt="image-20230115171237388" style="zoom:67%;" />

2.依次输入指令：

```
C:
cd Users\liukai\.android
keytool -list -v -keystore android.keystore
```

> AS debug.keystore的密钥默认是android
>
> 发布版的要自己设置

3.之后复制即可

![image-20230115172028571](C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230115172028571.png)



**包名**

![image-20230115161425049](C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230115161425049.png)

4.输入以上内容提交即可创建内容

5.在app目录下的build.gradle的android中配置sourceSets标签

![image-20230124213936232](C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230124213936232.png)

```java
sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
        }
    }

```

##### 代码实现

1.新建application类(MyApplication)进行地图初始化

```java
import android.app.Application;
import com.baidu.location.LocationClient;
import com.baidu.mapapi.CoordType;
import com.baidu.mapapi.SDKInitializer;

public class MyApplication extends Application {

    @Override
    public void onCreate() {
      
        super.onCreate();
   
        //在使用SDK各组件之前初始化context信息，传入ApplicationContext
//        SDKInitializer.initialize(this);
        SDKInitializer.setAgreePrivacy(getApplicationContext(),true);
        SDKInitializer.initialize(getApplicationContext());
        //自4.3.0起，百度地图SDK所有接口均支持百度坐标和国测局坐标，用此方法设置您使用的坐标类型.
        //包括BD09LL和GCJ02两种坐标，默认是BD09LL坐标。
        SDKInitializer.setCoordType(CoordType.BD09LL);
        LocationClient.setAgreePrivacy(true);
    }
}
```

2.修改AndroidManifest.xml文件

(1)在application标签中添加刚才新建的application项目名

![image-20230124214650947](C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230124214650947.png)

(2)添加权限

![image-20230124214749126](C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230124214749126.png)

```JAVA
    <!-- 访问网络，进行地图相关业务数据请求，包括地图数据，路线规划，POI检索等 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <!-- 获取网络状态，根据网络状态切换进行数据请求网络转换 -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <!-- 读取外置存储。如果开发者使用了so动态加载功能并且把so文件放在了外置存储区域，则需要申请该权限，否则不需要 -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <!-- 写外置存储。如果开发者使用了离线地图，并且数据写在外置存储区域，则需要申请该权限 -->
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <!-- 这个权限用于进行网络定位 -->
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <!-- 这个权限用于访问GPS定位 -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />


```

(3)在application 标签中写入代码密钥配置,value中的值为AK,修改为自己在百度地图申请的

```JAVA
 <meta-data
            android:name="com.baidu.lbsapi.API_KEY"
            android:value="ionrVhbqggVl3xu3Cf4C88teGrfGshFQ" />
```

(4)在application标签中放入定位权限

```JAVA
<service android:name="com.baidu.location.f"
            android:enabled="true"
            android:process=":remote"/>
```

<img src="C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230130011547461.png" alt="image-20230130011547461" style="zoom: 67%;" />

3.build.gradle(:app)中导入Rxpermissions依赖

```JAVA
 implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
 implementation 'io.reactivex.rxjava2:rxjava:2.0.5'
 implementation 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.3@aar'

```

4.布局文件(activity_bd)

```JAVA
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <com.baidu.mapapi.map.MapView
        android:id="@+id/bmapView"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:clickable="true" />

    <ImageButton
        android:id="@+id/ib_location"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_marginStart="8dp"
        android:layout_marginTop="8dp"
        android:layout_marginEnd="8dp"
        android:layout_marginBottom="8dp"
        android:background="@drawable/icon_location"
        android:onClick="resetLocation"
        android:visibility="gone" />

</LinearLayout>

```

5.java文件(BdActivity)

```JAVA
package com.example.webtest;
import android.Manifest;
import android.os.Build;
import android.os.Bundle;
import android.view.View;
import android.widget.ImageButton;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import com.baidu.location.BDLocation;
import com.baidu.location.BDLocationListener;
import com.baidu.location.LocationClient;
import com.baidu.location.LocationClientOption;
import com.baidu.mapapi.map.BaiduMap;
import com.baidu.mapapi.map.BitmapDescriptor;
import com.baidu.mapapi.map.BitmapDescriptorFactory;
import com.baidu.mapapi.map.MapPoi;
import com.baidu.mapapi.map.MapStatus;
import com.baidu.mapapi.map.MapStatusUpdateFactory;
import com.baidu.mapapi.map.MapView;
import com.baidu.mapapi.map.Marker;
import com.baidu.mapapi.map.MarkerOptions;
import com.baidu.mapapi.map.MyLocationData;
import com.baidu.mapapi.model.LatLng;
import com.example.R;
import com.tbruyelle.rxpermissions2.RxPermissions;
public class BdActivity extends AppCompatActivity {


    private MapView mMapView;

    private LocationClient mLocClient;
    private BaiduMap mBaiduMap;

    private BitmapDescriptor bitmap;//标点的图标
    private double markerLatitude = 0;//标点纬度
    private double markerLongitude = 0;//标点经度
    private ImageButton ibLocation;//重置定位按钮
    private Marker marker;//标点也可以说是覆盖物

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_bd);

        initView();//视图初始化

        try {
            checkVersion();//检查版本
        } catch (Exception e) {
            e.printStackTrace();
        }

        mapOnClick();//地图点击

    }


    private void checkVersion() throws Exception {
        if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.M){
            RxPermissions rxPermissions = new RxPermissions(this);
            rxPermissions.request(Manifest.permission.ACCESS_COARSE_LOCATION,
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.READ_PHONE_STATE,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE)
                    .subscribe(granted -> {
                        if (granted) {//申请成功
                            //发起连续定位请求
                            initLocation();// 定位初始化
                        } else {//申请失败
                            Toast.makeText(BdActivity.this,"权限未开启",Toast.LENGTH_SHORT).show();
                        }
                    });
        }else {
            initLocation();// 定位初始化
        }
    }

    private void initView() {
        // 地图初始化
        mMapView = (MapView) findViewById(R.id.bmapView);
        //回到当前定位
        ibLocation = (ImageButton) findViewById(R.id.ib_location);
        mMapView.showScaleControl(true);  // 设置比例尺是否可见（true 可见/false不可见）
        //mMapView.showZoomControls(false);  // 设置缩放控件是否可见（true 可见/false不可见）
        mMapView.removeViewAt(1);// 删除百度地图Logo

        mBaiduMap = mMapView.getMap();


        mBaiduMap.setOnMarkerClickListener(new BaiduMap.OnMarkerClickListener() {
            @Override
            public boolean onMarkerClick(Marker marker) {
                final String info = (String) marker.getExtraInfo().get("info");
                Toast.makeText(BdActivity.this, info, Toast.LENGTH_SHORT).show();
                return true;

            }
        });
    }

    /**
     * 地图点击
     */
    private void mapOnClick() {
        // 设置marker图标
        bitmap = BitmapDescriptorFactory.fromResource(R.drawable.icon_marka);
        mBaiduMap.setOnMapClickListener(new BaiduMap.OnMapClickListener() {
            @Override
            public void onMapPoiClick(MapPoi mapPoi) {

            }

            //此方法就是点击地图监听
            @Override
            public void onMapClick(LatLng latLng) {
                //获取经纬度
                markerLatitude = latLng.latitude;
                markerLongitude = latLng.longitude;
                //先清除图层
                mBaiduMap.clear();
                // 定义Maker坐标点
                LatLng point = new LatLng(markerLatitude, markerLongitude);
                // 构建MarkerOption，用于在地图上添加Marker
                MarkerOptions options = new MarkerOptions().position(point)
                        .icon(bitmap);
                // 在地图上添加Marker，并显示
                //mBaiduMap.addOverlay(options);
                marker = (Marker) mBaiduMap.addOverlay(options);
                Bundle bundle = new Bundle();
                bundle.putSerializable("info", "纬度：" + markerLatitude + "   经度：" + markerLongitude);
                marker.setExtraInfo(bundle);//将bundle值传入marker中，给baiduMap设置监听时可以得到它

                //点击地图之后重新定位
                try {
                    initLocation();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

    }


    /**
     * 定位初始化
     */
    public void initLocation() throws Exception {

        // 开启定位图层
        mBaiduMap.setMyLocationEnabled(true);
        // 定位初始化
        mLocClient = new LocationClient(this);
        MyLocationListener myListener = new MyLocationListener();
        mLocClient.registerLocationListener(myListener);
        LocationClientOption option = new LocationClientOption();

        option.setOpenGps(true);// 打开gps
        option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy);// 设置高精度定位
        option.setCoorType("bd09ll");//可选，默认gcj02，设置返回的定位结果坐标系
        option.setScanSpan(0);//可选，默认0，即仅定位一次，设置发起定位请求的间隔需要大于等于1000ms才是有效的
        option.setIsNeedAddress(true);//可选，设置是否需要地址信息，默认不需要
        option.setOpenGps(true);//可选，默认false,设置是否使用gps
        option.setIsNeedLocationDescribe(true);//可选，默认false，设置是否需要位置语义化结果，可以在BDLocation.getLocationDescribe里得到，结果类似于“在北京天安门附近”
        option.setIsNeedLocationPoiList(true);//可选，默认false，设置是否需要POI结果，可以在BDLocation.getPoiList里得到
        option.setIgnoreKillProcess(false);//可选，默认false，定位SDK内部是一个SERVICE，并放到了独立进程，设置是否在stop的时候杀死这个进程，默认杀死
        option.SetIgnoreCacheException(false);//可选，默认false，设置是否收集CRASH信息，默认收集
        option.setEnableSimulateGps(false);//可选，默认false，设置是否需要过滤gps仿真结果，默认需要
        mLocClient.setLocOption(option);
        mLocClient.start();//开始定位
    }

    /**
     * 点切换到其他标点位置时，重置定位显示，点击之后回到自动定位
     */
    public void resetLocation(View view) throws Exception {
        markerLatitude = 0;
        initLocation();
        marker.remove();//清除标点
    }

    /**
     * 定位SDK监听函数
     */
    public class MyLocationListener implements BDLocationListener {

        @Override
        public void onReceiveLocation(BDLocation location) {
            Toast.makeText(BdActivity.this,location.getAddrStr(),Toast.LENGTH_SHORT).show();
            // MapView 销毁后不在处理新接收的位置
            if (location == null || mMapView == null) {
                return;
            }
            double resultLatitude;
            double resultLongitude;

            if (markerLatitude == 0) {//自动定位
                resultLatitude = location.getLatitude();
                resultLongitude = location.getLongitude();
                ibLocation.setVisibility(View.GONE);
            } else {//标点定位
                resultLatitude = markerLatitude;
                resultLongitude = markerLongitude;
                ibLocation.setVisibility(View.VISIBLE);
            }

            MyLocationData locData = new MyLocationData.Builder()
                    .accuracy(location.getRadius())// 设置定位数据的精度信息，单位：米
                    .direction(location.getDirection()) // 此处设置开发者获取到的方向信息，顺时针0-360
                    .latitude(resultLatitude)
                    .longitude(resultLongitude)
                    .build();

            mBaiduMap.setMyLocationData(locData);// 设置定位数据, 只有先允许定位图层后设置数据才会生效
            LatLng latLng = new LatLng(resultLatitude, resultLongitude);
            MapStatus.Builder builder = new MapStatus.Builder();
            builder.target(latLng).zoom(20.0f);
            mBaiduMap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()));

        }

    }

    @Override
    protected void onResume() {
        super.onResume();
        // 在activity执行onResume时必须调用mMapView. onResume ()
        mMapView.onResume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        // 在activity执行onPause时必须调用mMapView. onPause ()
        mMapView.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 退出时销毁定位
        mLocClient.stop();
        // 关闭定位图层
        mBaiduMap.setMyLocationEnabled(false);
        // 在activity执行onDestroy时必须调用mMapView.onDestroy()
        mMapView.onDestroy();
    }
}



```

## 第十三章——继续进阶

#### 13.1 全局获取Context的技巧

>  <font color="gray"><b>在开发程序的过程中总会需要获取当前活动的Context，而每次调用的时候传入Context又比较麻烦，那有什么简单的办法呢？这就是我们接下来要讲解的</b></font>。



<span style="background-color:#00FFFF;"><b>使用步骤：</b></span>

1.**首先创建一个`MyApplication`类：**

```java
public class MyApplication extends Application {

    private static Context context;

    @Override
    public void onCreate() {
        super.onCreate();
        context = getApplicationContext();
    }
    //重写了父类的onCreate() 方法，并通过调用getApplicationContext() 方法得到了一个应用程序级别的Context ，然后又提供了一个静态的getContext() 方法，在这里将刚才获取到的Context进行返回。
    public static Context getContext() {
        return context;
    }

}
```

**2.在AndroidMainfest.xml中进行指定，告知系统在程序刚开始的时候就初始化`MyApplication`类**

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.networktest"
    android:versionCode="1"
    android:versionName="1.0" >
    ...
    <application
        android:name="com.example.networktest.MyApplication"
        ...>
        ...
    </application>
</manifest>
```

<span style="background-color:gold;"><b>原理：</b></span>

Android提供了一个`Application` 类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的Application 类，以便于管理程序内一些全局的状态信息，比如说全局`Context`。

<span style="background-color:#a2e043;"><b>使用范例：</b></span>

**1.直接使用**

```java
Toast.makeText(MyApplication.getContext(), "不错嘛",Toast.LENGTH_SHORT).show();
```

**2.或者创建一个工具类，在工具类中调用MyApplication.getContext()**

```java
public class ToastTool {
    public Context context;
    public static void makeToast(String message){
        Toast.makeText(MyApplication.getContext(),message,Toast.LENGTH_SHORT).show();
    }
}
```

**3.之后在活动之直接调用以下语句就可以：**

```java
ToastTool.makeToast("不错嘛");
```

==**4.结果：**==

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202304241341610.gif" alt="device-2023-04-24-13_-original-original (5)" style="zoom:25%;" />

> <span style="background-color:Darkorange;"><b>注意：</b></span>之前在学习`LitePal`的时候也是指定为<u>android:name="com.example.networktest.**LitePalApplication** "</u>，那要怎么避免这两者冲突呢？
>
> 其实很简单，只要在我们自己的Application中去调用LitePal的初始化方法就可以了
>
> ```java
> public class MyApplication extends Application {
> 
>  private static Context context;
> 
>  @Override
>  public void onCreate() {
>      context = getApplicationContext();
>      LitePal.initialize(context);
>  }
> 
>  public static Context getContext() {
>      return context;
>  }
> 
> }
> ```

#### 13.2 使用Intent传递对象

> **很多时候我们向要通过Intent传递数据，数据少了还好，但要是数据多了就麻烦了，比如通过Intent将一个对象中的数据传入到下一个活动中，一个一个put很麻烦，那有什么办法能够帮助我们避免这些操作呢？这就是我们接下来要讲的——通过实现Serializable或Parcelable接口来传递对象。**

**基本操作就是实现Serializable或Parcelable接口，并将对象作为额外数据（extra）添加到Intent中。我们先讲述第一种方法：**

##### 13.2.1 Serializable

> `Serializable`<u>是序列化的意思，表示将一个对象转换成可存储或可传输的状态。</u>序列化后的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方法也很简单，**只需要让一个类去实现Serializable这个接口就可以了。**

<span style="background-color:#00FFFF;"><b>使用方法：</b></span>

**1.实现Serializable接口**

```java
public class Person implements Serializable {
    //实现Serializable接口
    
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}
```

**2.添加对象到Intent中**

```java
Person person = new Person(1, "Example");
Intent intent = new Intent(this, AnotherActivity.class);
intent.putExtra("person", person);
startActivity(intent);
```

**3.从Intent中获取对象**

```java
Intent intent = getIntent();
Person person = (Person) intent.getSerializableExtra("person");
int id = person.getId();
String name = person.getName();
```

<span style="background-color:#a2e043;"><b>使用范例：</b></span>

**<font color=Gray>上面已经够详细了，直接展示代码：</font>**

**1.添加对象到Intent中**

```java
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Person person = new Person(1, "Example");
                Intent intent = new Intent(MyApplication.getContext(), AnotherActivity.class);
                intent.putExtra("person", person);
                startActivity(intent);
            }
        });
```

**2.从Intent中获取对象**

```java
 		textView=findViewById(R.id.textView);
        Intent intent = getIntent();
        Person person = (Person) intent.getParcelableExtra("person");
        int id = person.getId();
        String name = person.getName();
        textView.setText(name);
```

==**3.结果：**==

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202304241339111.gif" alt="device-2023-04-24-13_-original-original (4)" style="zoom: 25%;" />

**这样就能实现利用Intent传递对象了，接下来讲解`Parcelable`方式**

##### 13.2.2 Parcelable

> 不同于`Serializable`将整个对象序列化，`Parcelable`只是将一部分数据序列化，因此`Serializable`方式更高效。
>
> 在性能有要求的时候使用`Parcelable`方式。



<span style="background-color:#00FFFF;"><b>使用方法：</b></span>

**1.实现Parcelable接口**

```java
public class Person implements Parcelable {
    
private String name;

private int id;

...

@Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);  // 写出name
        dest.writeInt(id);  // 写出id
    }

    public static final Parcelable.Creator<Person> CREATOR = new Parcelable.
            Creator<Person>() {

        @Override
        public Person createFromParcel(Parcel source) {
            Person person = new Person();
            person.name = source.readString();  // 读取name
            person.id = source.readInt();  // 读取id
            return person;
        }

        @Override
        public Person[] newArray(int size) {
            return new Person[size];
        }
    };
    
}
```

**2.从Intent中获取对象**

<font color="gray"><b>添加对象到Intent跟Serializable实现的代码的代码差不多，只需要将获取对象的代码成下面的代码就好</b></font>

```java
Person person = (Person) getIntent().getParcelableExtra("person");
```

<span style="background-color:#a2e043;"><b>结果：</b></span>

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202304241352679.gif" alt="device-2023-04-24-13_-original-original (6)" style="zoom:25%;" />

<span style="background-color:gold;"><b>解析：</b></span>

`Parcelable` 的实现方式要稍微复杂一些。依旧是让Person 类去实现了`Parcelable` 接口，这样就必须重写`describeContents()` 和`writeToParcel()		 `	这两个方法。

1. `describeContents()`:这个方法返回当前对象存储在Parcel中的格式版本号。可以直接返回0。

2. `writeToParcel(Parcel dest, int flags)`:这个方法用于将当前对象写入Parcel。我们这里写入name和id两个字段。此外,还定义了一个CREATOR对象,这是一个内部类,实现了Parcelable.Creator接口。

   <u>这个接口也有两个方法:</u>

   1. `createFromParcel(Parcel source)`:从Parcel中构建一个新的对象。我们从Parcel中读取name和id,构建Person对象返回。(**<span style="background-color:Darkorange;"><b>注意：这里读取的顺序一定要和刚才写出的顺序完全相同！否则就会出现读取数据错误或者读取不到数据，上面那个demo中顺序互换后`AnotherActivity`只接受到了id值，甚至id值都是错的！</b></span>**)

   2. `newArray(int size)`:创建指定大小的对象数组。我们这里返回一个Person数组。而newArray() 方法中的实现就简单多了，只需要new出一个Person数组，并使用方法中传入的size作为数组大小就可以了。

#### 13.3 定制自己的日志工具

> <font color="gray"><b>你正在编写一个比较庞大的项目，期间为了方便调试，在代码的很多地方都打印了大量的日志。最近项目已经基本完成了，但是却有一个非常让人头疼的问题，之前用于调试的那些日志，在项目正式上线之后仍然会照常打印，这样不仅会降低程序的运行效率，还有可能将一些机密性的数据泄露出去。 那该怎么办呢？难道要一行一行地把所有打印日志的代码都删掉？显然这不是什么好点子，不仅费时费力，而且以后你继续维护这个项目的时候可能还会需要这些日志。因此，最理想的情况是能够自由地控制日志的打印，当程序处于开发阶段时就让日志打印出来，当程序上线了之后就把日志屏蔽掉。</b></font>

<span style="background-color:#00FFFF;"><b>使用方法：</b></span>

1.**新建一个LogUtil类，代码如下：**

```java
public class LogUtil {

    public static final int VERBOSE = 1;

    public static final int DEBUG = 2;

    public static final int INFO = 3;

    public static final int WARN = 4;

    public static final int ERROR = 5;

    public static final int NOTHING = 6;

    public static int level = VERBOSE;

    public static void v(String tag, String msg) {
        if (level <= VERBOSE) {
Log.v(tag, msg);
        }
    }

    public static void d(String tag, String msg) {
        if (level <= DEBUG) {
            Log.d(tag, msg);
        }
    }

    public static void i(String tag, String msg) {
        if (level <= INFO) {
            Log.i(tag, msg);
        }
    }

    public static void w(String tag, String msg) {
        if (level <= WARN) {
            Log.w(tag, msg);
        }
    }

    public static void e(String tag, String msg) {
        if (level <= ERROR) {
            Log.e(tag, msg);
        }
    }

}

```

> <font color="orange"><b>补充：</b></font>
>
> 在Android的Logcat日志中,VERBOSE是最低等级的日志级别。Android的日志分为6个级别:
>
> + **Verbose**(最低):Verbose级别日志打印所有的日志信息,它是最详细的日志级别。使用Log.v()打印Verbose日志。
> + **Debug**:Debug级别日志打印调试相关的日志信息,一般只在开发阶段启用。使用Log.d()打印Debug日志。
> + **Info**:Info级别日志打印一般性的日志信息,记录程序执行的流程或状态变化等普通信息。使用Log.i()打印Info日志。
> + **Warn**:Warn级别日志打印警告信息,表示程序执行过程中出现的一些异常情况,但程序本身依然可以继续运行。使用Log.w()打印Warn日志。
> + **Error**:Error级别日志打印错误信息,程序运行失败或出现意外情况。使用Log.e()打印Error日志。
> + **Assert(最高)**:Assert级别日志打印程序出错后的检查结果信息。它属于异常状态的日志信息。
>
> 这6个级别从低到高,日志量从多到少。
>
> 所以,VERBOSE日志级别会输出所有日志信息,包括DEBUG、INFO、WARN、ERROR和ASSERT等所有日志。
>
> Android Studio的Logcat选项卡可以设置日志级别来过滤日志。在编译版本中会自动过滤Debug及更低级别的日志。



<span style="background-color:#a2e043;"><b>使用范例：</b></span>

<font color=Gray>向使用Log一样使用就好</font>

```java
LogUtil.d("TAG","debug log");
```

**之后只需要修改level变量就能自由控制日志的打印行为了。**

#### 13.4 创建定时任务

[Android几种定时任务实现方式汇总](http://t.csdn.cn/03hh5)

##### 13.4.1 Handler实现方式

**一、采用Handle与线程的sleep(long)方法**



**1.定义一个Handler类，用于处理接受到的Message。**

```java
   Handler handler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(@NonNull Message msg) {
            // 要做的事情  
            switch(msg.what){
                   ......
            }
            
            return false;
        }
    });
```

**2.新建一个实现Runnable接口的线程类，如下：**

```java
 
public class MyThread implements Runnable {  
    @Override  
    public void run() {  
        // TODO Auto-generated method stub  
        while (true) {  
            try {  
                Thread.sleep(10000);// 线程暂停10秒，单位毫秒  
                Message message = new Message();  
                message.what = 1;  
                handler.sendMessage(message);// 发送消息  
            } catch (InterruptedException e) {  
                // TODO Auto-generated catch block  
                e.printStackTrace();  
            }  
        }  
    }  
}  
```

**3.在需要启动线程的地方加入下面语句：**

```java
new Thread(new MyThread()).start();  
```

**4.启动线程后，线程每10s发送一次消息。**

**5.最后记得在onDestroy回收清空**

在 `onDestroy()` 方法中，我们可以调用 `Thread.interrupt()` 方法中断当前线程，并将线程对象置为 null。具体代码如下：

```java
@Override
protected void onDestroy() {
    super.onDestroy();
    // 中断线程
    thread.interrupt();
    // 清空线程对象
    thread = null;
}
```

在这段代码中，我们首先调用 `thread.interrupt()` 方法中断当前线程。然后，将线程对象 `thread` 置为 null，以便系统可以回收该线程的资源。

##### 13.4.2采用Handler的postDelayed(Runnable, long)方法

**1.定义一个Handler类**

```java
Handler handler=new Handler();  
Runnable runnable=new Runnable() {  
    @Override  
    public void run() {  
        // TODO Auto-generated method stub  
        //要做的事情  
        handler.postDelayed(this, 2000);  
    }  
};  
```

**2.启动计时器**

```java
handler.postDelayed(runnable, 2000);//每两秒执行一次runnable.  
```

**3.停止计时器**

```java
handler.removeCallbacks(runnable);   
```

##### 13.4.3 采用Handler与timer及TimerTask结合的方法

**1.定义定时器、定时器任务及Handler句柄**

```java
private final Timer timer = new Timer(); 
private TimerTask task; 
Handler handler = new Handler() { 
    @Override 
    public void handleMessage(Message msg) { 
        // TODO Auto-generated method stub 
        // 要做的事情 
        super.handleMessage(msg); 
    } 
}; 
```

**2.初始化计时器任务**

```java
task = new TimerTask() {  
    @Override  
    public void run() {  
        // TODO Auto-generated method stub  
        Message message = new Message();  
        message.what = 1;  
        handler.sendMessage(message);  
    }  
};   
```

**3.启动定时器**

```java
timer.schedule(task, 2000, 2000);
```

**4.停止计时器**

```java
timer.cancel();  
```

