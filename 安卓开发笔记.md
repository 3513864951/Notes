```
通过edittext获取注册的密码，之后通过sharedpreferences储存，
```



### **一、一些基本杂碎的知识**

###### manifest文件   

```java

<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.project" android:versionCode="1"
				android:versionName="1.0">
// 权限和application是同级的				
<uses-permission android:name="android.permission.CAMERA" />
    
// 这里的android是设置app的名字，就是在手机桌面上的名字
<application android:label="@string/app_name" android:icon="@drawable/icon">
    // 这里的label设置的是活动的标题，界面名称
    <activity android:name=".MyActivity" android:label="@string/app_name"> 
            <intent-filter>
              <action android:name="android.intent.action.MAIN" /> 
              <category android:name="android.intent.category.LAUNCHER" />
              </intent-filter>
           </activity>
       </application>
     
	    </manifest>

```

#### 

###### 日志

Android中的日志工具类是Log（android.util.Log）， 在logcat下边看日志，还可以根据标签过滤。不要使用System.out 打印日志！

**Log.v()**。用于打印那些最为琐碎的、意义最小的日志信息。对应级别verbose，是Android日志里面级别最低的一种。

**Log.d()**。用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别debug，比verbose高一级。

**Log.i()**。用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别info，比debug高一级。

**Log.w()**。用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别warn，比info高一级。

**Log.e()**。用于打印程序中的错误信息，比如程序进入到了catch语句当中。当有错误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别error，比warn高一级。

###### SavedInstance

当程序快被杀死之前 也就是 生命周期 onpuse onstop 的时候当前界面处于不可见状态 会执行public void onSaveInstanceState(Bundle savedInstanceState) 这个方法 进行当前数据保存 以防止程序 因为内存不足被杀死丢失数据 Bundle主要用于传递数据；它保存的数据，是以key-value(键值对)的形式存在的。

###### setContentView

它的作用就是把我们的布局文件放在Activity中显示,一般都会传入一个布局文件的id

```java
//在onCreate()中使用
setContentView(R.layout.dialog_activity);
```

<img src="D:\Typora\typora-user-images\image-20221102221616358.png" alt="image-20221102221616358" style="zoom:50%;" />

###### Bundle

我们经常使用Bundle在Activity之间传递数据，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。

###### setOncClickListener

```java
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.first_layout);
    Button button1 = (Button) findViewById(R.id.button_1);//通过findViewById()获取到布局文件中定义的控件，这里获得button_1实例
    button1.setOnClickListener(new View.OnClickListener() //为button_1注册一个监视器，当点击button_1时，就会执行onClick()方法
    {
        @Override
        public void onClick(View v) {
            //逻辑代码
        }
    });
}

```

find view by id

### **二、活动的跳转 Intent（java）**

##### 一、第一种显式intent

```java
@Override
public void onClick(View v){
Intent intent = new Intent(MainActivity.this,Main2Activity.class);//从活动MainActivity跳转到Main2Activity
startActivity(intent);
}
```

##### 二、第二种隐式intent

通过在<activity>标签下配置<intent-filter>的内容，可以指定当前活动能够响应的action和category，打开AndroidManifest.xml，添加如下代码：

```java
<activity android:name=".SecondActivity" >
    /**
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_START" />
        <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
    **/
</activity>
```

在<action>标签中我们指明了当前活动可以响应com.example.activitytest.ACTION_START这个action，而<category>标签则包含了一些附加信息，更精确地指明了当前的活动能够响应的Intent中还可能带有的category。**<u>只有<action>和<category>中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</u>**(这俩可以按自己喜好命名)

修改FirstActivity中的代码如下：

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        /**
        Intent intent = new Intent("com.example.activitytest.ACTION_START");
        startActivity(intent);
        **/
        //android.intent.category.DEFAULT  为category的默认返回值，在调用 startActivity()时会自动将这个category添加到Intent中
    }
});
```

每个Intent只能指定一个action，但却能指定多个category,可以使用addCategory来添加category,修改FirstActivity中的代码如下:

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        /**
        Intent intent = new Intent("com.example.activitytest.ACTION_START");
        intent.addCategory("com.example.activtytest.MY_CATEGORY");
        startActivity(intent);
        **/
        //android.intent.category.DEFAULT  为category的默认返回值，在调用 startActivity()时会自动将这个category添加到Intent中
    }
});
```

同时在AdroidMainfest.xml中添加这个category的声明：

```java
<inent-filter>中添加
    <category android:name=com.example.activtytest.MY_CATEGORY"/>
```

这样就可以隐式启动活动了

##### 三、更多隐式Intent的用法

###### 1.在程序中展示一个网页

修改FirstActivity中onClick（）中的代码，如下：

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse("http://www.baidu.com"));
        startActivity(intent);
    }
});

```

首先指定了Intent的action是<u>Intent.ACTION_VIEW</u>，这是一个Android系统内置的动作，其常量值为<u>android.intent.action.VIEW</u>。然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个Uri对象传递进去。

点击按钮就可以打开浏览器了。

其次，还可以在<intent-filter>中再配置一个<data>标签，用于精确地确定当前活动能相应什么类型的活动<data>标签主要有以下内容：

```java
android:scheme。用于指定数据的协议部分，如上例中的http部分。
android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。
android:port。用于指定数据的端口部分，一般紧随在主机名之后。
android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。
android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。
```

只有Intent中携带的Data满足<data>中的要求时，当前活动才能够响应该Intent。

还有geo(表示显示地理位置),tel(拨打电话)等，例如拨打10086：

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(Intent.ACTION_DIAL);
        intent.setData(Uri.parse("tel:10086"));
        startActivity(intent);
    }
});
```



###### 2.使用intent向下一个活动传递数据

**原理：**Intent中提供了一系列putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出就可以了。

**示例：**

修改FirstActivity中的代码如下：

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    /**
        String data = "Hello SecondActivity";
        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
        intent.putExtra("extra_data", data);	//putExtra()方法接收两个参数，第一个参数是键，用于后面从Intent中取值，第二个参数才是真正要传递的数据。

         **/
        startActivity(intent);
    }
});

```

在SecondActivity中将传递的数据取出，并打印出来，代码如下所示：

```java
public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second_layout);
        /**
        Intent intent = getIntent();
        String data = intent.getStringExtra("extra_data");
        Log.d("SecondActivity", data);
        **/
    }

}
```

<u>可以通过getIntent()方法获取到用于启动SecondActivity的Intent，然后调用getStringExtra()方法，传入相应的键值，就可以得到传递的数据了。</u>这里由于我们传递的是字符串，所以使用getStringExtra()方法来获取传递的数据。如果传递的是整型数据，则使用getIntExtra()方法；如果传递的是布尔型数据，则使用getBooleanExtra()方法，以此类推。

点击FirstActivity中的按钮跳转到下一个活动并且在logcat中打印出了“Hello SecondActivity”

###### 3.返回数据给上一个活动

startActivityForResult()也可以用来启动活动，使用artActivityForResult()方法接收两个参数，第一个参数还是Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。修改FirstActivity中按钮的点击事件，代码如下所示：

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
        /**
        startActivityForResult(intent, 1);	//使用startActivityForResult()方法来启动SecondActivity，请求码只要是一个唯一值就可以
        **/
    }
});
```

接着修改SecondActivity中的代码如下：

```java
public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second_layout);
        /**
        Button button2 = (Button) findViewById(R.id.button_2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new Intent();//这个Intent仅仅是用于储存传递数据而已，它没有指定任何的“意图”。
                intent.putExtra("data_return", "Hello FirstActivity");
                setResult(RESULT_OK, intent);//第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值，第二个参数则把带有数据的Intent传递回去
                finish();//销毁活动
            }
        });
        **/
    }

}
```

使用startActivityForResult()方法来启动SecondActivity的，在SecondActivity被销毁之后会回调上一个活动的onActivityResult()方法，因此我们需要在FirstActivity中重写这个方法如下：

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
  // 第一个参数requestCode，即我们在启动活动时传入的请求码。第二个参数resultCode，即我们在返回数据时传入的处理结果。第三个参数data，即携带着返回数据的Intent。
    /**
    switch (requestCode) {	
        case 1:
            if (resultCode == RESULT_OK) {
                String returnedData = data.getStringExtra("data_return");
                Log.d("FirstActivity", returnedData);
            }
            break;
        default:
    }
    **/
}
```

由于在一个活动中有可能调用startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到onActivityResult()这个方法中，因此我们<u>首先要做的就是通过检查requestCode的值来判断数据来源。确定数据是从SecondActivity返回的之后，我们再通过resultCode的值来判断处理结果是否成功。</u>

如果用户不是点击按钮返回上一个活动，而是通过back键，可以通过在SecongActivity中重写onBackPressed()来解决：

```java
@Override
public void onBackPressed() {
    Intent intent = new Intent();
    intent.putExtra("data_return", "Hello FirstActivity");
    setResult(RESULT_OK, intent);
    finish();
}

```

这样点击back见返回后就会执行onBackPressed()中的代码

### **三、活动的故事**

###### 1.活动的生存期

```css
Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节，下面就来一一介绍这7个方法。
onCreate()。这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。
onStart()。这个方法在活动由不可见变为可见的时候调用。
onResume()。这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。
onPause()。这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。
onStop()。这个方法在活动完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。onDestroy()。这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。onRestart()。这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。
```



###### 2.活动回收时保存数据

onSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数据，以此类推。每个保存方法需要传入两个参数，**第一个参数是键（相当于姓名），用于后面从Bundle中取值，第二个参数是真正要保存的内容。**

在MainActivity中添加如下代码就可以将临时数据进行保存：

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    String tempData = "Something you just typed";//tempData存放这句话
    outState.putString("data_key", tempData);//data_key就相当于小明的姓名，在人群中叫小明出来就要叫小明的姓名
}

```

onCreate()方法其实也有一个Bundle类型的参数。这个参数在**一般情况下都是null**，但是如果在活动被系统回收之前有通过onSaveInstanceState()方法来保存数据的话，**这个参数就会带有之前所保存的全部数据**，我们只需要再通过相应的取值方法将数据取出即可。修改MainActivity的onCreate()方法，如下所示：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(TAG, "onCreate");
    setContentView(R.layout.activity_main);
    if (savedInstanceState != null) {
        String tempData = savedInstanceState.getString("data_key");//
        Log.d(TAG, tempData);//打印tempData中的数据
    }
```



###### 3.定义一个主活动

使用Activity时，在manifest中声明此Activity，并设置为主活动。如果没设置，无法在启动器中看到这应用程序，这种程序通常作为第三方服务供其它应用在内部进行调用。

```java
<activity
    android:name=".FirstActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
 <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
</activity>
```

java代码中的活动

```java
// 基本活动定义
import androidx.appcompat.app.AppCompatActivity;
import android.util.Log;
import android.os.Bundle;

public class MainActivity2 extends AppCompatActivity {

    // 在Activity创建时被系统调用
    @Override//下面是对父类的重写
    protected void onCreate(Bundle savedInstanceState) {
        // savedInstanceState 也就是保存Activity的状态
        super.onCreate(savedInstanceState);
        // 加载布局文件
        setContentView(R.layout.Second_layout);
        //把我们的布局Second_layout放在Activity中显示
    }

    @Override
    protected void onStart() {
        Log.v("start", "act start");
        super.onStart();
    }
}


```

###### 4.活动的启动模式

**standard**模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。

修改FirstActivity中onCreate()方法的代码，如下所示：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d("FirstActivity", this.toString());
    setContentView(R.layout.first_layout);
    Button button1 = (Button) findViewById(R.id.button_1);
    button1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
        **    
            Intent intent = new Intent(FirstActivity.this, FirstActivity.class);
            startActivity(intent);//点击按钮从第一个活动打开第一个活动
            连续点击三次，会创建三个FirstActivity放在栈区，因此也需要连续退出三次才能销毁程序
            **
        }
    });
}

```

**singleTop** 在启动活动时如果发现**返回栈的栈顶**已经是该活动，则认为可以直接使用它，不会再创建新的活动实例；如果不是栈顶就会创建新的实例

**singleTask** 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则**直接使用该实例，并把在这个活动之上的所有活动统统出栈**，如果没有发现就会创建一个新的活动实例

**SingleInstance** 这种模式是最特殊的模式，这种模式是为了让**不同的app之间可以共享同一个活动**，如果你的app想让别的app调用你的某一个界面，就可以用这种模式，这种模式会**为你想共享的界面单独创造出一个单独使用的返回栈**，不会与别的返回栈共同使用

在FirstActivity界面点击按钮进入到SecondActivity，然后在SecondActivity界面点击按钮进入到ThirdActivity。

然后按下Back键进行返回，会发现ThirdActivity直接返回到了FirstActivity，再按下Back键又会返回到SecondActivity，再按下Back键才会退出程序

由于FirstActivity和ThirdActivity是存放在同一个返回栈里的，当在ThirdActivity的界面按下Back键，ThirdActivity会从返回栈中出栈，那么FirstActivity就成为了栈顶活动显示在界面上，因此也就出现了从ThirdActivity直接返回到FirstActivity的情况。然后在FirstActivity界面再次按下Back键，这时当前的返回栈已经空了，于是就显示了另一个返回栈的栈顶活动，即SecondActivity。最后再次按下Back键，这时所有返回栈都已经空了，也就自然退出了程序。

![image-20221103092532211](D:\Typora\typora-user-images\image-20221103092532211.png)

###### 5.知晓当前是哪一个活动

首先需要新建一个BaseActivity类。右击com.example.activitytest包→New→Java Class，在弹出的窗口出输入BaseActivity，

```java
public class BaseActivity extends AppCompatActivity {
//让BaseActivity继承自AppCompatActivity，并重写onCreate()方法
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());//从onCreate()方法中获取了当前实例的类名，并通过Log打印了出来
    }
}
```

修改FirstActivity、SecondActivity和ThirdActivity的继承结构，让它们不再继承自AppCompatActivity，而是继承自BaseActivity。而由于BaseActivity又是继承自AppCompatActivity的，所以项目中所有活动的现有功能并不受影响，它们仍然完全继承了Activity中的所有特性。

之后在运行程序就会打印当前界面是哪个界面了

###### 6.随时随地退出程序

新建一个<u>ActivityCollector类作为活动管理器</u>，代码如下所示：

```java
 public static List<Activity> activities = new ArrayList<>();

    public static void addActivity(Activity activity) {
        activities.add(activity);//添加活动的成员方法
    }

    public static void removeActivity(Activity activity) {
        activities.remove(activity);//从任务管理器中移除活动
    }
    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();//销毁活动
            }
        }
        activities.clear();
    }

}
```

通过一个List来暂存活动，然后提供了一个**addActivity()方法用于向List中添加一个活动**，提供了一个removeActivity()方法用于从List中移除活动，最后提供了一个finishAll()方法用于将List中存储的活动全部销毁掉。接下来修改BaseActivity中的代码，如下所示：

```java

public class BaseActivity extends AppCompatActivity {


@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
        ActivityCollector.addActivity(this);//将正在创建的活动添加到任务管理器中
    }
/*
    @Override
    protected void onDestroy() {
        super.onDestroy();
        ActivityCollector.removeActivity(this);//表示将一个马上要销毁的活动从任务管理器中移除
    }

}

*/
```

不管什么地方退出程序，只需要调用ActivityCollector.finishAll()方法就可以了。例如在ThirdActivity界面想通过点击按钮直接退出程序，只需将代码改成如下所示：

```java
public class ThirdActivity extends BaseActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("ThirdActivity", "Task id is " + getTaskId());
        setContentView(R.layout.third_layout);
        /*****以下为添加代码*****/
        Button button3 = (Button) findViewById(R.id.button_3);
        button3.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ActivityCollector.finishAll();
            }
        });

    }
}


```

还可以在销毁所有活动的代码后面再加上杀掉当前进程的代码，以保证程序完全退出，杀掉进程的代码如下所示：<u>android.os.Process.killProcess(android.os.Process.myPid());</u>

###### 7.启动程序的最佳写法

假设SecondActivity中需要用到两个非常重要的字符串参数，在启动SecondActivity的时候必须要传递过来，缩写代码如下：

```java

//原先的方法：
    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
	intent.putExtra("param1", "data1");
	intent.putExtra("param2", "data2");
	startActivity(intent);

//现在的方法

public class SecondActivity extends BaseActivity {
//优点：可以清晰地知道启动SecondActivity需要哪些数据
    public static void actionStart(Context context, String data1, String data2) {
        Intent intent = new Intent(context, SecondActivity.class);
        intent.putExtra("param1", data1);
        intent.putExtra("param2", data2);
        context.startActivity(intent);
    }
    ...
}
```

还简化了启动SecondActivity的代码

```java
button1.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {

SecondActivity.actionStart(FirstActivity.this, "data1", "data2");
    }
});


```

### **四、常用控件的使用**

###### TextView

textview中可以添加的设置：

**android:grivity**：指定文字的对齐方式

**android:textSize**可以指定文字的大小，以sp作为单位

**android:textColor**可以指定文字的颜色

<img src="D:\Typora\typora-user-images\image-20221103174339142.png" alt="image-20221103174339142" style="zoom: 50%;" />

```java
    <TextView
        android:id="@+id/text_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
            
        android:textSize="24sp"
        android:textColor="#00ff00"
        android:text="This is text view!"
        android:gravity="center"
            
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</LinearLayout>
```

###### Button

```java
    <Button
        android:id="@+id/button1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Button"//屏幕显示出来的是大写的"BUTTON"如果想禁用系统的默认大写
		android:textALLCaps="false"//加入这行代码可以禁用这一特性
        />

```

###### 两种监视器的写法

在MainActivity中为Button的点击事件注册一个监听器，如下所示：

```java

接下来我们可以在MainActivity中为Button的点击事件注册一个监听器，如下所示：public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
       /*
       //每当点击按钮都会执行监听器中的onClick()方法
        Button button = (Button) findViewById(R.id.button);
		button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 在此处添加逻辑
            }
        });
        */
    }
}


```

第二种方法

也可以使用实现接口的方式来进行注册，代码如下所示：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                // 在此处添加逻辑
                break;
            default:
                break;
        }
    }
}
```



###### EditText

作用：允许用户在控件中输入和编辑内容，并可以在程序中对这些内容加以处理

示例：在activity_main.xml中添加代码如下

```java
<EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
            android:hint="Type something here"//在输入框中没有内容是显示
                android:maxLines="2"//限定文本显示框最大能显示的行数
        />
```

<img src="D:\Typora\typora-user-images\image-20221103185638555.png" alt="image-20221103185638555" style="zoom:50%;" /><img src="D:\Typora\typora-user-images\image-20221103210852088.png" alt="image-20221103210852088" style="zoom:50%;" />

```java

private EditText editText;
······
@Override
            public void onClick(View v) {
                
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();

            }
```

首先通过findViewById()方法得到EditText的实例，然后在按钮的点击事件里调用EditText的getText()方法获取到输入的内容，再调用toString()方法转换成字符串，最后使用Toast将输入的内容显示出来。

###### imagineView

展示图片

图片通常都是放在以“drawable”开头的目录下的。目前项目中有一个空的drawable目录，不过由于这个目录没有指定具体的分辨率，所以一般不使用它来放置图片。因此在res目录下新建一个drawable-xhdpi目录，然后将事先准备好的两张图片img_1.png和img_2.png复制到该目录当中。接下来修改activity_main.xml，如下所示：

```java
ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/img_1 "//androidsrc属性给ImagineView指定了一张图片
        />
```

通过代码动态地更改ImageView图片,修改ManActivity的代码：

```java
 @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText=(EditText) findViewById(R.id.edit_text);
       /** imageView=(ImageView) findViewById(R.id.image_view);**/

        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
              
               /** imageView.setImageResource(R.drawable.img_2);**/通过调用这个方法将图片改成img_2,点击一下按钮就能改变
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
```

###### ProgressBar

用于在界面上显示一个进度条，表示程序正在加载一些数据

修改activity_main中的代码如下：

```java
 <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
```

如何才能让进度条在数据加载的时侯消失呢？

修改MainActivity中的代码如下：

```java

public class MainActivity extends AppCompatActivity {
private EditText editText;
private ImageView imageView;
/**
private ProgressBar progressBar;
**/
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button1 = (Button) findViewById(R.id.button);
        editText=(EditText) findViewById(R.id.edit_text);
        imageView=(ImageView) findViewById(R.id.image_view);
        /**
        progressBar=(ProgressBar) findViewById(R.id.progress_bar);
        **/
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               /**
               if (progressBar.getVisibility() == View.GONE) {
                    progressBar.setVisibility(View.VISIBLE);
                } else {
                    progressBar.setVisibility(View.GONE);
                }
                **/
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
}

```

在按钮的点击事件中，我们通过getVisibility()方法来判断ProgressBar是否可见，如果可见就将ProgressBar隐藏掉，如果不可见就将ProgressBar显示出来。重新运行程序，然后不断地点击按钮，就会看到进度条会在显示与隐藏之间来回切换。

```java
getVisibility();//获取控件可见性
setVisibility();//设置控件可见性	
	View.GONE //不可见不占空间
	View.INVISIBLE //不可见 占空间
	View.VISIBLE //可见

```

还可以给ProgressBar指定不同的样式

修改activity_main中的代码如下：

```java
style="?android:attr/progressBarStyleHorizontal"//进度条
        android:max="100"//进度条的最大值
```

还可以动态的更改进度条的进度

在onClick()中添加如下代码：

```java
		int progress = progressBar.getProgress();
                progress = progress + 10;//
                progressBar.setProgress(progress);
```

###### AlertDialog

简介：AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。

用法：

修改MainActivity中的代码如下：

```java
public void onClick(View v){
AlertDialog.Builder dialog = new AlertDialog.Builder (MainActivity.
                    this);
                dialog.setTitle("This is Dialog");//对话框标题
                dialog.setMessage("Something important.");//对话框显示的信息
                dialog.setCancelable(false);
                dialog.setPositiveButton("OK", new DialogInterface.
                    OnClickListener() {//对话框中的按钮 OK
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                dialog.setNegativeButton("Cancel", new DialogInterface.
                    OnClickListener() {//对话框中的按钮 Cancle
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                dialog.show();//显示对话框
}


```

点击按钮后，

<img src="D:\Typora\typora-user-images\image-20221105115048774.png" alt="image-20221105115048774" style="zoom:50%;" />

######  ProgressDialog

介绍：ProgressDialog跟AlertDialog类似，都能够屏蔽掉其他控件的交互能力，不同的是这个控件会显示一个进度条表示当前操作比较耗时

修改MainActivity中的代码如下：

```java
 button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ProgressDialog progressDialog=new ProgressDialog(MainActivity.this);
                progressDialog.setTitle("这个是加载界面");//设置标题
                progressDialog.setMessage("加载中······");//设置内容
                progressDialog.setCancelable(true);//可否取消属性
                progressDialog.show();//显示
            }
        });
```

点击按钮后结果如下：

<img src="D:\Typora\typora-user-images\image-20221105155412386.png" alt="image-20221105155412386" style="zoom: 50%;" />

### **五、RecyclerView**

![image-20221108221117484](D:\Typora\typora-user-images\image-20221108221117484.png)

本文以 [RecyclerView]([(1条消息) RecyclerView简单使用(非常详细)_渣渣宝的博客-CSDN博客_recyclerview使用](https://blog.csdn.net/weixin_47311938/article/details/116099827?ops_request_misc=%7B%22request%5Fid%22%3A%22166772200616782388075490%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=166772200616782388075490&biz_id=0&spm=1018.2226.3001.4187))为参考

源码附上以表尊敬：



recy_list.xml中的代码

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="#cccccc"
    android:paddingTop="10dp"
    android:paddingBottom="10dp"
    android:paddingRight="20dp"
    android:paddingLeft="20dp">


    <ImageView
        android:id="@+id/head"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginRight="20dp"
        android:src="@android:mipmap/sym_def_app_icon" />


    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:orientation="vertical">

        <TextView
            android:id="@+id/name"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:text="小白"
            android:textColor="@color/black"
            android:textSize="16sp" />

        <TextView
            android:id="@+id/news"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:textColor="#666666"
            android:text="今天搬了多少砖"/>

    </LinearLayout>

    <TextView
        android:id="@+id/time"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:gravity="end"
        android:textColor="#999999"
        android:textSize="14sp"
        android:text="2021年4月24日\n19:02:50"/>

</LinearLayout>

```

activity_main.xml

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</LinearLayout>
```



MainActiviy中的代码

```java
package Fragment;

import android.os.Bundle;

import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.example.loginactivity.R;
import com.example.loginactivity.adaptor.Backlog_Adaptor;
import com.example.loginactivity.database.Backlog;
import com.example.loginactivity.database.User;

import org.litepal.LitePal;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class BacklogFragment extends Fragment {
    private View view;
    private static int user_id;
    private List<Map<String,String>> backlogList=new ArrayList<Map<String,String>>();//键和值都是字符串，也可以改成其他类型，   通过包含关系就知道List包含多个map，而map中可以存放多个键和值
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        view=inflater.inflate(R.layout.fragment_backlog, container, false);
        return view;
    }
    @Override
    public void onStart () {
        super.onStart();
        backlogList.clear();//清空list子项数据，实现刷新
        initContent();
        RecyclerView recyclerView = (RecyclerView)view.findViewById(R.id.recyclerView_backlog);
        LinearLayoutManager layoutManager = new LinearLayoutManager(getContext());//通过管理器获得布局
        recyclerView.setLayoutManager(layoutManager);//设置recyclerView的布局显示方式
        Backlog_Adaptor backlog_adaptor = new Backlog_Adaptor (backlogList);//传入数据
        //绑定RecyclerView
        recyclerView.setAdapter(backlog_adaptor);
        //notifyDataSetChanged()可以在修改适配器绑定的数组后，不用重新刷新Activity，通知Activity更新list
        backlog_adaptor.notifyDataSetChanged();
    }
    private void initContent ()//自定义方法,初始化内容，就是刚打开Activity时显示的内容

    {
        List<User> userList= LitePal.select("idd").find(User.class);
        user_id=userList.get(0).getIdd();
        String s_user_id=Integer.toString(user_id);
        Log.d("asdf", s_user_id);
        List<Backlog> backloglist = LitePal.order("id desc").where("user_id=?", s_user_id).find(Backlog.class);//通过Backlog.class参数查询Backlog表，返回值是一个list集合
        for (Backlog backlogs:backloglist) {//遍历list集合中的Backlog对象
            String content = backlogs.getContent();
            String time = backlogs.getTime();
            Map<String, String> map = new HashMap<String, String>();
            map.put("content", content);
            map.put("time", time);
            backlogList.add(map);//将map加入到list中，取出时通过position取出list中的特定map
        }
    }












}
```

Backlog_Adaptor.java中的代码

```java
package com.example.loginactivity.adaptor;

import android.content.Context;
import android.content.Intent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.example.loginactivity.editor.BacklogEditor;
import com.example.loginactivity.R;

import java.util.List;
import java.util.Map;

public class Backlog_Adaptor extends RecyclerView.Adapter<Backlog_Adaptor.ViewHolder>{
    private List<Map<String,String>> mBacklogList;
    private Context context;
    private View.OnLongClickListener onLongClickListener;
    
    //构造器，传入数据
    public Backlog_Adaptor(List<Map<String,String>> contentLis){
        mBacklogList=contentLis;
    }
    
    
    //创建控件并实例化控件
    static class ViewHolder extends RecyclerView.ViewHolder{//创建控件
        TextView showContent;
        TextView showTime;
        View backlogView;
        
        //控件实例化
        public ViewHolder(View view){//通过转化为view的布局获得控件实例
            super(view);
            backlogView=view;
            showContent=view.findViewById(R.id.show_content);
        }
    }
    
    
    
    
//加载的布局实例化，后面好改这个xml里面控件的一些属性
    @Override
    public Backlog_Adaptor.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {//ViewHolder是每个list中的item，该方法用于创建ViewHolder的实例
        //当传递一个null的变量到被@NonNul修饰的方法中时，IDE会警告
        //使用LayoutInflater加载view，再将view传给ViewHolder来实例化
        View view=LayoutInflater.from(parent.getContext()).inflate(R.layout.backlog_list,parent,false);//parent指这个布局放在哪，false指不为该布局的外部再嵌套一层父布局，绑定元素建立后显示的UI
        //xml 布局转换为对应的 View 对象
        final ViewHolder holder=new ViewHolder(view);//创建holder来实例化
      
        return holder;

    }
    
    
    //是用于对子项的数据进行赋值,会在每个子项被滚动到屏幕内时执行。position得到当前项的实例
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {//绑定ViewHolder时的回调函数，position代表item下标，指的是传入的noteList元素的下标
            holder.showContent.setText(mBacklogList.get(position).get("content"));//通过position将数据与控件绑定，给控件添加数据
          holder.backlogView.setOnClickListener(new View.OnClickListener() {//添加元素的点击事件
            @Override
            public void onClick(View view) {
                int position= holder.getAdapterPosition();//获得点击的位置
                String content=mBacklogList.get(position).get("content");//获得List中的第position个map中的特定数据，之前一个map中传入了一个item的所有数据
                String time=mBacklogList.get(position).get("time");
                Intent intent=new Intent(parent.getContext(), BacklogEditor.class);
                intent.putExtra(BacklogEditor.CONTENT,content);
                intent.putExtra(BacklogEditor.TIME,time);
                parent.getContext().startActivity(intent);
            }
        });
    }

    @Override
    public int getItemCount() {
        return mBacklogList.size();
    }//控制创建的item的条数，返回的就是条数
}

```

Backlog.java中的代码

```java
package com.example.loginactivity.database;

import org.litepal.crud.LitePalSupport;

public class Backlog extends LitePalSupport {
    private String remind_time;//提醒时间
    private String content;//内容
    private int id;
    private String time;//编辑时间
    private User user;
    public String getRemind_time() {
        return remind_time;
    }
    public void setRemind_time(String remind_time) {
        this.remind_time = remind_time;
    }
    public String getContent() {
        return content;
    }
    public void setContent(String content) {
        this.content = content;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }

    public String getTime() {
        return time;
    }

    public void setTime(String time) {
        this.time = time;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}

```

backlog_list.xml中代码

<mark>这个是每一个元素显示时的UI，将会在onCreateViewHolde方法中绑定r</mark>

<img src="C:\Users\liukai\AppData\Roaming\Typora\typora-user-images\image-20230228094957931.png" alt="image-20230228094957931" style="zoom:67%;" />

```java
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="345dp"
    android:layout_height="80dp"
    android:layout_gravity="center_horizontal"
    android:layout_margin="4dp"
    android:background="@drawable/backlog_background"
    android:orientation="vertical">

    <LinearLayout
        android:id="@+id/linearLayout4"
        android:layout_width="320dp"
        android:layout_height="0dp"
        android:orientation="vertical"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">

        <LinearLayout
            android:id="@+id/linearLayout"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginLeft="20dp"
            android:orientation="vertical">

            <TextView
                android:id="@+id/show_content"
                android:layout_width="match_parent"
                android:layout_height="54dp"
                android:ellipsize="end"
                android:gravity="bottom"
                android:maxLines="1"
                android:text="6666"
                android:textColor="@color/black"
                android:textSize="30dp"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/textView5"
                android:layout_width="match_parent"
                android:layout_height="4dp"
                android:background="@color/black" />

        </LinearLayout>

    </LinearLayout>


</androidx.constraintlayout.widget.ConstraintLayout>
```

1.创建布局，添加RecycleView和每个List布局

<img src="D:\Typora\typora-user-images\image-20221107154733942.png" alt="image-20221107154733942" style="zoom:50%;" />

2.之后给RecyclerView添加id

```java
 <androidx.recyclerview.widget.RecyclerView  //这个布局就是list显示的位置
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
```

3.创建backlog_list.xml

修改代码如前方展示的代码

4.之后在MainActivity中绑定

```java
public class MainActivity extends AppCompatActivity {
 private RecyclerView recycler;//创建
  @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();//初始化控件方法  initial
    }
    private void initView()//自定义方法
    {
        recycler = findViewById(R.id.recycler);//绑定RecyclerView
    }

```

5.<u>**创建**</u>适配器FruitAdapter类

适配器Adapter，可以让开发者自定义recyclerview绑定的数据，通过上面创建的recy_list文件模板来创建一堆item

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder {
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view) {
            super(view);
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }
    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.fruit_item, parent, false);//第一个参数传入要加载的布局文件的id,第二个给加载好的布局文件再添加一个父布局，
        ViewHolder holder = new ViewHolder(view);
        return holder;
    }
    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }
    @Override
    public int getItemCount() {
        return mFruitList.size();
    }

}

```

*****************************************************************************************************************************************************************************************************************************************************************************************

6.绑定的适配器，生成列表

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits(); // 初始化水果数据
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);//调用RecyclerView的setAdapter()方法将构建好的适配器对象传递进去，这样RecyclerView和数据之间的关联就建立完成了
    }

    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }

}
```

这样就完成了构建，可以运行程序

**实现横向滚动和瀑布流布局**

首先对fruit_item做如下修改

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
   android:orientation="vertical"//使得布局里的元素垂直排列以便于横向滑动
    android:layout_width="100dp"//将宽度指定为固定值是因为每种水果的文字长度不一致，如果用wrap_content的话，RecyclerView的子项就会有长有短，非常不美观；而如果用match_parent的话，就会导致宽度过长，一个子项占满整个屏幕。
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"//水平居中
        />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"//水平居中
        android:layout_marginLeft="10dp" />//使文字和图片之间保持一定的距离

</LinearLayout>
```

**修改MainActivity中的代码**

在onCreate中添加如下代码

```java
layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);//设置布局的排列方式，默认是纵向排列，修改为横向排列
```

**瀑布流布局**

修改fruit_item.xml中的代码

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"//瀑布流布局的宽度应该根据列数自动适配
    android:layout_height=" wrap_content"
    android:layout_margin="5dp" >//页边空白，让子项之间存在间距

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal" />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"//水果信息左对齐，居中太奇怪
        android:layout_marginTop="10dp" />

</LinearLayout>
```

接着修改MainActivity中的代码

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        StaggeredGridLayoutManager layoutManager = new 
        StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
            //创建了一个StaggeredGridLayoutManager的实例。StaggeredGridLayoutManager的构造函数接收两个参数，第一个参数用于指定布局的列数，传入3表示会把布局分为3列；第二个参数用于指定布局的排列方向，传入StaggeredGridLayoutManager.VERTICAL表示会让布局纵向排列
//这样瀑布流就构建完成了，为了美观可以修改下面的代码
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit(
                getRandomLengthName("Apple"), R.drawable.apple_pic);//效果：会随机生成由随机个"Apple"组成的名字name
            fruitList.add(apple);
            Fruit banana = new Fruit(
                getRandomLengthName("Banana"), R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit(
                getRandomLengthName("Orange"), R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit(
                getRandomLengthName("Watermelon"), R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit(
                getRandomLengthName("Pear"), R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit(
                getRandomLengthName("Grape"), R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit(
                getRandomLengthName("Pineapple"), R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit(
                getRandomLengthName("Strawberry"), R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit(
                getRandomLengthName("Cherry"), R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit(
                getRandomLengthName("Mango"), R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }

    private String getRandomLengthName(String name) {
        Random random = new Random();
        int length = random.nextInt(20) + 1;//生成重复的次数在1~20之间
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < length; i++) {
            builder.append(name);
        }
        return builder.toString();
    }

}
```

**RecyclerView的点击事件**

RecyclerView中没有setOnClickListener()方法，而是需要给子项具体的View去注册

修改FruitAdapter.xml中的代码

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {

    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder {
        View fruitView;//这三个都是内部定义的类
        ImageView fruitImage;
        TextView fruitName;
//构造器
        public ViewHolder(View view) {
            super(view);//将控件的实例进行缓存，放在view中
            fruitView = view;
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            f
                +tName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }
//成员方法的重写
    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.
            fruit_item, parent, false);
        final ViewHolder holder = new ViewHolder(view);
        holder.fruitView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(),
                    Toast.LENGTH_SHORT).show();
            }
        });
        holder.fruitImage.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked image " + fruit.getName(),
                    Toast.LENGTH_SHORT).show();
            }
        });
        
        return holder;
    }
    ...
}
```

### **六、SharedPreferences储存**

SharedPreferences是使用键值对的方式来存储数据的。也就是说，当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。

##### 一、将数据储存到SharedPreferences中

**1.首先要获得SharedPreferences对象**

**1)Context类中的GetSharedPreferences**

第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，第二个参数用于指定操作模式，目前只有MODE_PRIVATE这一种模式可选，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。

**2）Activity类中的getPreferences()方法**

这个方法和Context中的getSharedPreferences()方法很相似，<u>不过它只接收一个操作模式参数</u>，因为使用这个方法时会自动将当前活动的类名作为SharedPreferences的文件名。

**3）PreferenceManager类中的getDefaultSharedPreferences()方法**

这是一个静态方法，它接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences文件。得到了SharedPreferences对象之后，就可以开始向SharedPreferences文件中存储数据了，主要可以分为3步实现。

```java
(1) 调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象。
(2) 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。
(3) 调用apply()方法将添加的数据提交，从而完成数据存储操作。
```

**使用流程如下：**

新建一个SharedPreferencesTest项目，然后修改activity_main中的代码：

```java
LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <Button
        android:id="@+id/save_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Save data"
        />
</LinearLayout>
```

意图是通过点击按钮将数据储存到SharedPreferences文件中。修改MainActivity中的代码

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button saveData = (Button) findViewById(R.id.save_data);
        saveData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                SharedPreferences.Editor editor = getSharedPreferences("data",
                    MODE_PRIVATE).edit();//通过getSharedPreferences()指定SharedPreferences的文件名为data,之后向editor中添加三种不同的数据
                editor.putString("name", "Tom");//前面那个参数是键，用于后面取值
                editor.putInt("age", 28);
                editor.putBoolean("married", false);
                editor.apply();//调用apply()方法进行提交从而完成数据储存操作
            }
        });
    }
}
```

##### 二、从SharedPreferences中读取数据

在activity_main.xml中添加如下代码

```java
 <Button
        android:id="@+id/restore_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Restore data"//增加一个还原数据的按钮
        />
```

修改MainActivity中的代码

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ...
        Button restoreData = (Button) findViewById(R.id.restore_data);
        restoreData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE);//data是之前储存的文件名
                String name = pref.getString("name", "");//第一个是键，第二个参数是默认值，表示当前传入的值找不到会以什么样的默认值返回
                int age = pref.getInt("age", 0);
                boolean married = pref.getBoolean("married", false);
                Log.d("MainActivity", "name is " + name);
                Log.d("MainActivity", "age is " + age);
                Log.d("MainActivity", "married is " + married);
                 Toast.makeText(MainActivity.this, name, Toast.LENGTH_SHORT).show();//添加Toast提示显示姓名
            }
        });
    }

}
```

##### 三、实现记住密码的功能

修改activity_login.xml中的代码

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".LoginActivity">
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Account:" />

        <EditText
            android:id="@+id/account"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical" />
    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="60dp">
        <TextView
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:layout_gravity="center_vertical"
            android:textSize="18sp"
            android:text="Password:" />

        <EditText
            android:id="@+id/password"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_gravity="center_vertical"
            android:inputType="textPassword" />
    </LinearLayout>
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <CheckBox//复选框控件，用户可以通过点击的方式进行选中和取消,使用这个空间来表示是否需要记住密码
            android:id="@+id/remember_pass"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="18sp"
            android:text="Remember password" />
    </LinearLayout>
    <Button
        android:id="@+id/login"
        android:layout_width="match_parent"
        android:layout_height="60dp"
        android:text="Login" />
</LinearLayout>
```

效果图

![image-20221109221211521](D:\Typora\typora-user-images\image-20221109221211521.png)

接着修改LoginActivity中的代码

```java
 @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        pref = PreferenceManager.getDefaultSharedPreferences(this);//每个应用都有一个默认的配置文件preferences.xml，使用getDefaultSharedPreferences获取
        accountEdit = (EditText) findViewById(R.id.account);
        passwordEdit = (EditText) findViewById(R.id.password);
        rememberPass = (CheckBox) findViewById(R.id.remember_pass);
        login = (Button) findViewById(R.id.login);
        boolean isRemember = pref.getBoolean("remember_password", false);//初始值为false,不执行下方的if语句
        if (isRemember) {
            // 将账号和密码都设置到文本框中
            String account = pref.getString("account", "");
            String password = pref.getString("password", "");
            accountEdit.setText(account);
            passwordEdit.setText(password);
            rememberPass.setChecked(true);
        }
        login.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String account = accountEdit.getText().toString();
                String password = passwordEdit.getText().toString();
                // 如果账号是admin且密码是123456，就认为登录成功
                if (account.equals("admin") && password.equals("123456")) {
                    editor = pref.edit();
                    if (rememberPass.isChecked()) { // 检查复选框是否被选中
                        editor.putBoolean("remember_password", true);//再次登陆后，就会自动读取密码并自动填充
                        editor.putString("account", account);//开始储存密码账号
                        editor.putString("password", password);
                    } else {
                        editor.clear();
                    }
                    editor.apply();
                    Intent intent = new Intent(LoginActivity.this, MainActivity.
                            class);
                    startActivity(intent);
                    finish();
                }
                else {
                    Toast.makeText(LoginActivity.this, "account or password is invalid",
                            Toast.LENGTH_SHORT).show();
                }
            }

        });
    }
}
```

### **七、LitePal**

https://github.com/LitePalFramework/LitePal

要使用LitePal的第一步就是编辑app/build.gradle文件，在denpendencies闭包中添加如下内容：

```java
implementation 'org.litepal.guolindev:core:3.2.3'//3.2.3是版本号，最新的可以去官网查看
```

接下来配置litepal.xml文件，创建一个assets目录，然后再此目录下再建一个litepal.xml文件

<img src="D:\Typora\typora-user-images\image-20221110170453340.png" alt="image-20221110170453340" style="zoom: 80%;" />

接着编辑litepal.xml文件中的内容如下

```java
<?xml version="1.0" encoding="utf-8"?>
<litepal>
    <dbname value="BookStore"/>

    <version value="1"/>

    <list>
    </list>
</litepal>

```

最后配置一下LitePalApplication,修改AndroidMainfest.xml中的代码如下：

```java
<application
        android:name="org.litepal.LitePalApplication"
            //这个是必须的
```

> 如果已经有了name,手写一个继承LitePalApplication的类作为程序的appliction
>
> ```java
> import org.litepal.LitePalApplication;
> 
> public class BaseApplication extends LitePalApplication {
>     
> }
> ```
>
> 设置BaseApplication为程序Application
>
> ```java
>   <application
>         android:name="com.jw.firstapp.application.BaseApplication"
>         ...>
> </application>
> ```

加入name后可能会报错，在如下文件中添加如下代码

![image-20230318204155670](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202303182041809.png)

```java
jcenter()
        maven { url 'https://jitpack.io' }
```

之后再添加如下代码

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202303182040161.png" alt="image-20230318204016966" style="zoom: 67%;" />

```java
buildscript {repositories {maven{ url 'https://maven.aliyun.com/repository/google'}
    maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'}
    maven{ url 'https://maven.aliyun.com/repository/public'}
    maven{ url 'https://maven.aliyun.com/repository/jcenter'}
    google()
    jcenter()}
    dependencies {
        classpath 'com.android.tools.build:gradle:7.1.2'
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files}
    }}
```

##### 一、**创建和升级数据库**

修改activity_main中的代码如下：

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >

    <Button
        android:id="@+id/create_database"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="创建数据库"
        />

    <Button
        android:id="@+id/add_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="添加数据"
        />

    <Button
        android:id="@+id/update_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="更新数据"
        />

    <Button
        android:id="@+id/delete_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="删除数据"
        />

    <Button
        android:id="@+id/query_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="查询数据"
        />

</LinearLayout>
```

创建一个张book表，定义一个Book类：

```java
public class Book {

    private int id;

    private String author;

    private double price;

    private int pages;

    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public int getPages() {
        return pages;
    }

    public void setPages(int pages) {
        this.pages = pages;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
}
```

之后将Book类添加到映射模型中，修改litepal.xml中的代码：

```java



 <list>
        <mapping class="com.example.litepal.Book"/>
    </list>






```

接着修改MainActivity中的代码

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button createDatabase = (Button) findViewById(R.id.create_database);
        createDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Connector.getDatabase();//创建数据库，这是计算机内部自带的创建数据库的
            }
        });
        
    }
    
}





```

##### **二、升级数据库**

比如想要添加一个press(出版社)列，直接修改Book类中的代码，添加一个press字段即可，如下：

```java
public class Book extends LitePalSupport{//记得继承，否则无法运用save()方法

    ...

    private String press;

    ...

    public String getPress() {
        return press;
    }

    public void setPress(String press) {
        this.press = press;
    }

}
```

如果想要添加一个Category表，则需要新建一个Category类，代码如下：

```java

public class Category {

    private int id;
    private String categoryName;
    private int categoryCode;

   

    public void setId(int id) {
        this.id = id;
    }

    public void setCategoryName(String categoryName) {
        this.categoryName = categoryName;
    }

    public void setCategoryCode(int categoryCode) {
        this.categoryCode = categoryCode;
    }

}
```

改完我们想改的东西，还要在litepal.xml中将版本号加1并将Category类添加到映射模型中

```java

 <version value="2" />
     .....
<list>
        <mapping class="com.example.litepal.Book"/>
        <mapping class="com.example.litepal.Category"/>
    </list>

```

> 在实际应用中更加复杂，有可能一个人对应多本书，一本书有一个作者(Author.class)，这就要学习LitePal表关联
>
> [Android数据库高手秘籍(四)——使用LitePal建立表关联](http://t.csdn.cn/e5xst)
>
> 





##### **三、使用litepal添加数据**

调用Book类中各种的set方法对数据进行设置，之后调用book.save()方法完成添加

```java
......
Button addDatabase = (Button) findViewById(R.id.add_data);
        addDatabase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Book book=new Book();
                book.setAuthor("MaNiuBi");
                book.setId(114514);
                book.setName("maNiuBiDis");
                book.save();
            }
        });
```

##### 四、**使用LitePal更新数据**

```css
最简单的更新方式就是对已储存的对象重新设置，之后调用save()即可。对象是否储存调用modle.isSave()方法的结果判断，true代表已储存，false代表没有
只有在两种情况下才会返回true：
1.之前已经调用过model.save（方法去添加数据	
2.另一种是通过LitePal提供的查询API查出来
```

第一种方法：

```java
...
        Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Book book = new Book();
                book.setName("The Lost Symbol");
                book.setAuthor("Dan Brown");
                book.setPages(510);
                book.setPrice(19.95);
                book.setPress("Unknow");
                book.save();
                book.setPrice(10.99);
                book.save();
            }
        });
```

但这种更新方式只能对已储存的对象进行操作

第二种方法

```java
Button updateData = (Button) findViewById(R.id.update_data);
        updateData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Book book = new Book();
                book.setPrice(14.95);
                book.setPress("Anchor");
                book.updateAll("name = ? and author = ?", "The Lost Symbol", "Dan Brown");
            }
        });

```

首先new出了一个Book的实例，然后直接调用setPrice()和setPress()方法来设置要更新的数据，最后再调用updateAll()方法去执行更新操作。

**注意：**updateAll()方法中可以指定一个条件约束,如果不指定条件语句的话，就表示更新所有数据。这里我们指定将所有书名是The Lost Symbol并且作者是Dan Brown的书价格更新为14.95，出版社更新为Anchor。

如果想要将数据恢复为默认值不能用上面的方式来set数据，LitePal提供的setToDefault()方法可以解决这个问题

```java
Book book = new Book();
book.setToDefault("pages");
book.updateAll();
```

这段代码的意思是，将所有书的页数都更新为0，因为updateAll()方法中没有指定约束条件，因此更新操作对所有数据都生效了。

##### 五、**使用LitePal删除数据**

修改MainActivity中的代码

```java
...
        Button deleteButton = (Button) findViewById(R.id.delete_data);
        deleteButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                DataSupport.deleteAll(Book.class, "price < ?", "15");
            }
        });
```

用LitePal.deleteAll()来删除数据第一个参数用来指定哪张表，后面的参数用来指定约束条件，如果不指定约束条件就意味着要删除表中的所有数据

##### 六、**用LitePal来查询数据**

修改MainActivity中的代码

```java
Button queryButton = (Button) findViewById(R.id.query_data);
        queryButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                List<Book> books = DataSupport.findAll(Book.class);//查询这张表中所有数据，并返还一个Book类型的List集合
                for (Book book: books) {//遍历List集合中的Book对象并将其中的信息全部打印出来
                    Log.d("MainActivity", "book name is " + book.getName());
                    Log.d("MainActivity", "book author is " + book.getAuthor());
                    Log.d("MainActivity", "book pages is " + book.getPages());
                    Log.d("MainActivity", "book price is " + book.getPrice());
                    Log.d("MainActivity", "book press is " + book.getPress());
                }
            }
        });

```

```css
select()方法用于指定查询哪几列的数据，对应了SQL当中的select关键字。比如只查name和author这两列的数据，就可以这样写：List<Book> books = DataSupport.select("name", "author").find(Book.class);
where()方法用于指定查询的约束条件，对应了SQL当中的where关键字。比如只查页数大于400的数据，就可以这样写：List<Book> books = DataSupport.where("pages > ?", "400").find(Book.class);
order()方法用于指定结果的排序方式，对应了SQL当中的order by关键字。比如将查询结果按照书价从高到低排序，就可以这样写：List<Book> books = DataSupport.order("price desc").find(Book.class);
其中desc表示降序排列，asc或者不写表示升序排列。limit()方法用于指定查询结果的数量，比如只查表中的前3条数据，就可以这样写：List<Book> books = DataSupport.limit(3).find(Book.class);
offset()方法用于指定查询结果的偏移量，比如查询表中的第2条、第3条、第4条数据，就可以这样写：List<Book> books = DataSupport.limit(3).offset(1).find(Book.class);
```

### **八、最佳UI体验**

##### 一、Toolbar

1. 两种不带Actionbar的主题

   ```java
   <style name="Theme.Toolbar" parent="Theme.AppCompat.NoActionBar">
   ```

<img src="D:\Typora\typora-user-images\image-20221116212927361.png" alt="image-20221116212927361" style="zoom:50%;" />

```java
<style name="Theme.Toolbar" parent="Theme.AppCompat.Light.NoActionBar">
```

<img src="D:\Typora\typora-user-images\image-20221116213034038.png" alt="image-20221116213034038" style="zoom:50%;" />

在布局中添加Toolbar

修改activity_main中的代码

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
    
  </LinearLayout>
```

常用属性

```css
app:navigationIcon 导航图标，一般情况下放回退按钮，点击退回上一个界面。
android:background 工具栏颜色
app:title 标题
app:titleTextColor 标题文字颜色
app:titleMarginStart 标题与左侧间距
app:subtitle 子标题
app:subtitleTextColor 子标题颜色
app:logo 工具栏logo
```

修改activity_main.xml中的代码如下：

```java
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">
    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:title="大标题"
        app:subtitle="小标题"
        app:titleTextColor="@color/purple_200"
        app:titleMarginStart="5dp"
        app:navigationIcon="@drawable/back_button"
        />
  </LinearLayout>
```

<img src="D:\Typora\typora-user-images\image-20221116221536177.png" alt="image-20221116221536177" style="zoom: 80%;" />

可以通过添加一些action按钮来让Toolbar更加丰富

<img src="D:\Typora\typora-user-images\image-20221116222407084.png" alt="image-20221116222407084" style="zoom:80%;" />

创建一个menu文件夹，之后右键menu文件夹--->New-->Menu resource file,创建一个toolbar.xml文件,修改其中的代码如下：

```java
<item
    android:id="@+id/backup"
    android:icon="@drawable/back_button"
    android:title="Backup"
    android:orderInCategory="80"
    app:showAsAction="ifRoom|withText"
    />
    <item
        android:id="@+id/backup_1"
        android:title="Backup"
        app:showAsAction="always" />
    <item
        android:id="@+id/delete"
        android:title="Delete"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/settings"
        android:title="Settings"
        app:showAsAction="never" />
```



![image-20221116223558002](D:\Typora\typora-user-images\image-20221116223558002.png)

上面代码中组件的添加和Menu绘制的方法类似，唯一的区别就是app:showAsAction值的不同，而该属性正是 Toolbar关键所在。 app:showAsAction 属性共有 4个值，分别如下。

| always   | 这个值会使菜单项一直显示在 ToolBar上。                       |
| -------- | ------------------------------------------------------------ |
| ifRoom   | 如果有足够的空间，这个值会使菜单项显示在 Tool Bar上。        |
| never    | 这个值会使菜单项永远都不出现在 ToolBar上。                   |
| withText | 这个值会使菜单项和它的图标、菜单文本一起显示。一般和ifRoom一起通过“ |

app:showAsAction 属性值为 ifRoom|withText，表示如果有空间，那么就连同文字一起显示在标题栏中，否则就显示在菜单栏中。
而当app:showAsAction 属性值为 never时，该项作用为Menu不显示在菜单组件中。

> **注意：**Toolbar中的action只会显示图标，菜单中的action只会显示文字

设置action按钮的点击事件

修改MainActivity中的代码，

```java
public class MainActivity extends AppCompatActivity {

    ...

          toolbar=findViewById(R.id.toolbar);
       	  setSupportActionBar(toolbar);
    public boolean onCreateOptionsMenu(Menu menu) {//加载toolbar.xml这个菜单文件
        getMenuInflater().inflate(R.menu.toolbar, menu);
        return true;//表示允许创建菜单
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {//处理各个按钮的点击事件
        switch (item.getItemId()) {//判断点击的按钮是哪个
            case R.id.backup:
                Toast.makeText(this, "You clicked Backup", Toast.LENGTH_SHORT).
                    show();
                break;
            case R.id.delete:
                Toast.makeText(this, "You clicked Delete", Toast.LENGTH_SHORT).
                    show();
                break;
            case R.id.settings:
                Toast.makeText(this, "You clicked Settings", Toast.LENGTH_SHORT).
                    show();
                break;
            default:
        }
        return true;
    }

}
```

<img src="D:\Typora\typora-user-images\image-20221117083911315.png" alt="image-20221117083911315" style="zoom: 25%;" />

##### **二、滑动菜单**

**1.修改布局文件**

```java
<?xml version="1.0" encoding="utf-8"?>

<androidx.drawerlayout.widget.DrawerLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/DrawerLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
        
</androidx.drawerlayout.widget.DrawerLayout>
```

**2.添加主界面和侧滑界面**

> DrawerLayout 包含主界面和侧滑界面。对于 DrawerLayout 内的界面布局有以下几个要求：
> **1.主界面布局一定要位于所有侧滑界面布局之前，宽度与高度应设置为 match_parent ，并且不能包含 layout_gravity 标签。**
> **2.侧滑界面必须设置 layout_gravity 属性，且当该属性值为 start 或 left 时该侧滑界面从左侧滑出，当该属性值为 end 或 right 时，该侧滑界面从右侧滑出。**
> **3.侧滑界面的高度属性建议设定为 match_parent ，宽度属性建议设置为一个常数。**
> **4.界面任意一个垂直边缘最多允许配置一个侧滑界面，如果在布局时为单个垂直边缘配置了多个侧滑界面，则运行时将引发异常。**

```java
<?xml version="1.0" encoding="utf-8"?>
<androidx.drawerlayout.widget.DrawerLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawerLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <!--主界面不需要设置layout_gravity-->
    <LinearLayout
        android:id="@+id/main_layout"

        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="horizontal">
        <TextView
            android:text="这是主界面"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"/>

    </LinearLayout>

    <!--侧滑界面设置layout_gravity:start或者left为左滑，end或者right为右滑-->
    <LinearLayout
        android:id="@+id/left_layout"
        android:layout_width="300dp"
        android:background="#22aa22"

        android:layout_height="match_parent"
        android:orientation="vertical"
        android:layout_gravity="start">
        <TextView
            android:text="这是侧滑界面"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"/>
        <ListView
            android:id="@+id/id_lv"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:divider="#CD853F"
            android:dividerHeight="2dp" >
        </ListView>
        <Button
            android:id="@+id/btn"
            android:text="按钮"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"/>
    </LinearLayout>

</androidx.drawerlayout.widget.DrawerLayout>

```

**3.控制侧滑界面的状态**

DrawerLayout 提供了以下方法操作侧滑界面

```java
void closeDrawer(View drawerView) \\ 关闭侧滑界面
void openDrawer(View drawerView) \\ 打开侧滑界面
boolean isDrawerOpen(View drawer) \\ 判断侧滑界面是否处于打开状态
```

4.**为侧滑界面添加监视器**

```java
 DrawerLayout mDrawerLayout = (DrawerLayout) findViewById(R.id.drawerLayout);
 mDrawerLayout.addDrawerListener(new DrawerLayout.DrawerListener() {
            @Override
            public void onDrawerSlide(@NonNull View drawerView, float slideOffset) {
            //侧滑界面滑动中回调该方法
            }
            @Override
            public void onDrawerOpened(@NonNull View drawerView) {
                //侧滑界面打开时回调该方法
            }
            @Override
            public void onDrawerClosed(@NonNull View drawerView) {
                //侧滑界面关闭时回调该方法
            }
            @Override
            public void onDrawerStateChanged(int newState) {
                //侧滑界面状态改变时回调该方法
            }
        });

```

5.**在左上角添加一个导航按钮，点击按钮可以打开侧滑栏**

```java
 DrawerLayout mDrawerLayout = (DrawerLayout) findViewById(R.id.drawerLayout);
        ActionBar actionBar=getSupportActionBar();//得到ActionBar实例，
        if(actionBar!=null){
            actionBar.setDisplayHomeAsUpEnabled(true);//让导航按钮显示出来
            actionBar.setHomeAsUpIndicator(R.drawable.back_button);//导航按钮的图标
        }
@Override
    public boolean onOptionsItemSelected(MenuItem item) {//处理各个按钮的点击事件
        switch (item.getItemId()) {//判断点击的按钮是哪个
            case android.R.id.home:
                DrawerLayout mDrawerLayout = (DrawerLayout) findViewById(R.id.drawerLayout);
                mDrawerLayout.openDrawer(GravityCompat.START);//点击后打开侧滑栏
            case R.id.backup:
                Toast.makeText(this, "You clicked Backup", Toast.LENGTH_SHORT).
                        show();
                break;
            case R.id.delete:
                Toast.makeText(this, "You clicked Delete", Toast.LENGTH_SHORT).
                        show();
                break;
            case R.id.settings:
                Toast.makeText(this, "You clicked Settings", Toast.LENGTH_SHORT).
                        show();
                break;
            default:
        }
        return true;
```

##### 三、Navigation View

**1.添加依赖**

打开app/build.gradle文件

```java
 //noinspection GradleCompatible

dependencies {

    //noinspection GradleCompatible


//不用添加依赖
    implementation 'de.hdodenhof:circleimageview:2.1.0'
    implementation 'org.litepal.guolindev:core:3.2.3'
    implementation 'androidx.appcompat:appcompat:1.4.1'
    implementation 'com.google.android.material:material:1.5.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
}
```

**2.创建nav_menu.xml文件**

![image-20221118215853270](D:\Typora\typora-user-images\image-20221118215853270.png)

**3.修改nav_menu中的代码**

```java
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <group android:checkableBehavior="single">
        <item
            android:id="@+id/nav_call"
            android:icon="@drawable/back_button"
            android:title="Call" />
        <item
            android:id="@+id/nav_friends"

            android:title="Friends" />
        <item
            android:id="@+id/nav_location"

            android:title="Location" />
        <item
            android:id="@+id/nav_mail"

            android:title="Mail" />
        <item
            android:id="@+id/nav_task"

            android:title="Tasks" />
    </group>

</menu>
```

**4.创建一个nav——header.xml文件，如下图**

![image-20221118220330744](D:\Typora\typora-user-images\image-20221118220330744.png)

**5.修改其中的代码**

```java
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="180dp"
    android:padding="10dp"
    android:background="?attr/colorPrimary">

    <de.hdodenhof.circleimageview.CircleImageView//将图片圆形化
        android:id="@+id/icon_image"
        android:layout_width="70dp"
        android:layout_height="70dp"
        android:layout_centerInParent="true"//居中显示
        android:src="@drawable/menu" />

    <TextView
        android:id="@+id/mail"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:text="tonygreendev@gmail.com"
        android:textColor="#FFF"
        android:textSize="14sp" />

    <TextView
        android:id="@+id/username"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/mail"
        android:text="Tony Green"
        android:textColor="#FFF"
        android:textSize="14sp" />

</RelativeLayout>
```

6.准备好menu和headerLayout后，就可以使用NavigationView了，修改activity_main.xml中的代码

```java
<com.google.android.material.navigation.NavigationView

        android:id="@+id/nav_view"
        android:layout_height="match_parent"
        android:layout_width="match_parent"
        android:layout_gravity="start"
        app:menu="@menu/nav_menu"
        app:headerLayout="@layout/nav_header"
        />
```

7。处理菜单项中的点击事件

```java

```

##### **四、悬浮按钮和可交互提示**

###### 一、FloatingActionButton

1.添加依赖

```java
implementation 'com.android.support:design:28.0.0'
```

2.修改activity_main.xml中的代码

```java
  <android.support.design.widget.FloatingActionButton
        android:id="@+id/fab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:foregroundGravity="bottom|right"
        android:src="@drawable/back_button"
        android:layout_marginTop="16dp"
        />
```

3.设置完后，你会发现按钮下面还有投影，还可以指定FloatActionButton来指定悬浮高度

```java
  <android.support.design.widget.FloatingActionButton
        android:id="@+id/fab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:foregroundGravity="bottom|right"
        android:src="@drawable/back_button"
        android:layout_marginTop="16dp"
        app:elevation="8dp"//高度越大，投影范围越小，投影效果越浓
        />
```

4.处理FloatingActionButton的点击事件

修改MainActivity中的代码

```java
 //在OnCreat()方法中添加
FloatingActionButton fab=(FloatingActionButton) findViewById(R.id.fab) ;
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(MainActivity.this, "FAB CLICKED", Toast.LENGTH_SHORT).show();
                
            }
        });
```





















