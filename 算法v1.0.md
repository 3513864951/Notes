



# Remember

​																		**随着知识水平的不同，理解随时会变，以自己当时的理解为准。**

> ### 二叉树的一般解题思路
>
> + 先序遍历（深度优先搜索）
>
> + 中序遍历（深度优先搜索）（尤其二叉搜索树）
>
> + 后序遍历（深度优先搜索）
>
> + 层序遍历（广度优先搜索）（尤其按照层来解决问题的时候）
>
> + 序列化与反序列化（结构唯一性问题）
>
> + 三种遍历图解
>
>   ![img](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131520240.jpeg)
>
>   ![img](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131520375.jpeg)
>
>   

#### 递归三部曲

##### ①确定递归函数的参数和返回值

参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode`。

```cpp
public TreeNode invertTree(TreeNode root)
```

##### ②确定终止条件

当前节点为空的时候，就返回

```cpp
    if (root == null) {
        return null;
    }
```

##### ③确定单层递归的逻辑

因为是先前序遍历，先翻转左右子树，然后交换左右子节点。

```cpp
    // 利用函数定义，先翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    // 然后交换左右子节点
    root.left = right;
    root.right = left;
```

基于这递归三步法，代码基本写完，C++代码如下：

```CPP
// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    // 利用函数定义，先翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    // 然后交换左右子节点
    root.left = right;
    root.right = left;

    // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root
    return root;
}
```

#### 一、翻转二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

对应题目：力扣第 226 题「[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)」

![image-20230708195200239](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307081952445.png)

##### <span style="background-color:gold;"><b>思路：</b></span>

> 不难发现，只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### 1.遍历的思维

```java
// 主函数
TreeNode invertTree(TreeNode root) {
    // 遍历二叉树，交换每个节点的子节点
    traverse(root);
    return root;
}

// 二叉树遍历函数
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    /**** 前序位置 ****/
    // 每一个节点需要做的事就是交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 遍历框架，去遍历左右子树的节点
    traverse(root.left);
    traverse(root.right);
}
```



###### 2.分解问题的思维（递归）

```java
TreeNode invertTree(TreeNode root)
定义作用：翻转root节点对应的树

利用前序遍历
class Solution {
    // 先序遍历--从顶向下交换
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        
        //逻辑代码：交换左右子树（root的左右节点）
        TreeNode tmp=root.right;
        root.right=root.left;
        root.left=tmp;
        
		//把左、右子树里面的节点进行翻转并赋值给左右子树
        root.right=invertTree(root.right);
        root.left=invertTree(root.left);

        return root;
    }
}

利用中序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
        	
        	//先将左子树的节点全部翻转
            invertTree(root.left);
        
        	//逻辑代码：交换左右子树（root的左右节点）
            TreeNode rightNode= root.right; // 保存右节点
            root.right = root.left;
            root.left = rightNode;
        
            // 将右子树的节点进行翻转：因为此时左右节点已经交换了,所以此时的右节点为root.left
            invertTree(root.left); 
        
         return root;
    }
}

利用后序遍历
 class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 后序遍历-- 从下向上交换
            if (root == null) return null;
            
            //把左、右子树里面的节点进行翻转并赋值给左右子树（）
            TreeNode leftNode = invertTree(root.left);
            TreeNode rightNode = invertTree(root.right);
            
            //逻辑代码：交换左右子树（root的左右节点）
            root.right = leftNode;
            root.left = rightNode;
            
            return root;
        }
    }

```

###### 3.层序遍历

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        Queue<TreeNode> q=new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()){
            int size =q.size();
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                
                //逻辑代码：交换左右节点
                TreeNode treeNode=node.right;
                node.right=node.left;
                node.left=treeNode;
                
                if(node.right!=null){
                    q.offer(node.right);
                }
                if(node.left!=null){
                    q.offer(node.left);
                }


            }
        }

        return root;
    }
}
```

#### 二、对称二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

[[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)]

![image-20230708210306231](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307082103284.png)



##### <span style="background-color:gold;"><b>思路：</b></span>

> **首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！**
>
> 对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。
>
> 那么如何比较呢？
>
> 比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307082119390.png" alt="20210203144624414" style="zoom:50%;" />
>
> 那么遍历的顺序应该是什么样的呢？
>
> 本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。
>
> **正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**
>
> 其实后序也可以理解为是一种回溯遍历。

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### 1.分解问题（递归）

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left,root.right);
    }
    //1.确定递归函数的参数和返回值
    boolean compare(TreeNode right,TreeNode left){
        
    //2.确定终止条件
        if(right==null&&left==null){//左右都为空，对称，返回true
            return true;
        }else if(right==null&&left!=null){//左节点为空，右节点不为空，不对称，return false
            return false;
        }else if(right!=null&&left==null){//左不为空，右为空，不对称 return false
            return false;
        }else if(left.val!=right.val){//左右都不为空，比较节点数值，不相同就return false
            return false;
        }
    //3.确定单层递归的逻辑
        boolean outside=compare(left.left,right.right);
        boolean inside=compare(left.right,right.left);
        boolean result=outside&&inside;
        return result;
    }

}
```

###### 2.层序遍历（队列）

> 同时遍历两棵树

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {

        Queue<TreeNode> queue=new LinkedList();
        //左右节点
        queue.offer(root.left);
        queue.offer(root.right);
        while(!queue.isEmpty()){
            int size =queue.size();
            for(int i=0;i<size;i++){
                TreeNode left=queue.poll();
                TreeNode right=queue.poll();
                
			
//                if(left==null&&right==null){
//                    continue;
//                }else if(left!=null&&right==null){
//                    return false;
//                }else if(left==null&&right!=null){
//                    return false;
//                }else if(left.val!=right.val){
//                    return false;
//                }
				//代码简化
                if(left==null&&right==null){
                    continue;
                }	                
                if(left==null||right==null||left.val!=right.val){
                    return false;
                }
                //外侧节点先进，里侧节点后进
                queue.offer(left.left);
                queue.offer(right.right);
                queue.offer(left.right);
                queue.offer(right.left);

        }

       
    }
     return true;
}
}
```

#### 三、二叉树展开为链表

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[将二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)」

![image-20230709153045864](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091530917.png)



##### <span style="background-color:gold;"><b>思路：</b></span>

> `flatten`:压平
>
> 从该函数的意思上就知道这个函数是用来压平树的，因此定义：**给 `flatten` 函数输入一个节点 `root`，那么以 `root` 为根的二叉树就会被拉平为一条链表**。
>
> 如何利用这个定义来完成算法？你想想怎么把以 `root` 为根的二叉树拉平为一条链表？
>
> 很简单，以下流程：
>
> 1、将 `root` 的左子树和右子树拉平。
>
> 2、将 `root` 的右子树接到左子树下方，然后将整个左子树作为右子树。
>
> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091440174.jpg" alt="2" style="zoom:50%;" />
>
> 至于如何把 `root` 的左右子树拉平，不用你操心，`flatten` 函数的定义就是这样，交给他做就行了。





##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    // 定义：将以 root 为根的树拉平为链表
    public void flatten(TreeNode root) {
        if(root==null){
            return;
        }
		 // 先递归拉平左右子树
        flatten(root.left);
        flatten(root.right);
		
        /****后序遍历位置****/
        // 1、左右子树已经被拉平成一条链表
        TreeNode left=root.left;
        TreeNode tmp=root.right;
		
        // 2、将左子树放到右子树
        root.right=left;
		root.left=null;
        
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode p=root;
        while(p.right!=null){
            p=p.right;
        }
        p.right=tmp;//把捋直的原来的右子树接上去



    }


}
```

#### 四、构造最大二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)」

![image-20230709153227590](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091532648.png)



![image-20230709153249507](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091532559.png)





##### <span style="background-color:gold;"><b>思路：</b></span>

> 看完题目中的解释基本上就能看出来有一种浓浓的递归味道在里面，因此我们**考虑递归的方法**来解决。
>
> 构造二叉树**先考虑前序遍历**，先要遍历数组把找到最大值 `max`，从而把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左右子树。



##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums,0,nums.length-1);
    }
    //辅助函数
    TreeNode build(int[] nums,int lo,int hi){
        //终止条件和返回值
        if(lo>hi){
            return null;
        }

        //找到最大值和对应的索引
        int max=Integer.MIN_VALUE,index=-1;//这个两个一定要这样写，不然很容易栈溢出和越界（被上了一课）
        for(int i=lo;i<=hi;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        
        // 先构造出根节点
        TreeNode node=new TreeNode(max);

        //构建左子树
         node.left=build(nums,lo,index-1);
         //构建右子树
         node.right=build(nums,index+1,hi);

        
        return node;


    }
}
```

#### 五、通过前序和中序结果构造二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091747770.png" alt="image-20230709174723674" style="zoom:80%;" />

##### <span style="background-color:gold;"><b>思路：</b></span>

>    每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的当然是把想办法把自己先构造出来，然后想办法构造自己的左右子树。
>
>    所以，我们要遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左右子树。

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums,0,nums.length-1);
    }
    TreeNode build(int[] nums,int lo,int hi){
        //终止条件和返回值
        if(lo>hi){
            return null;
        }

        //找到最大值和对应的索引
        int max=Integer.MIN_VALUE,index=-1;
        for(int i=lo;i<=hi;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        
        //构建中间节点
        TreeNode node=new TreeNode(max);

        //构建左子树
         node.left=build(nums,lo,index-1);
         //构建右子树
         node.right=build(nums,index+1,hi);

        
        return node;


    }
}
```

#### 六、通过前序和中序遍历结果构造二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」

![image-20230711220929694](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307112209804.png)

##### <span style="background-color:gold;"><b>思路：</b></span>

> [思路降解](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/#%E9%80%9A%E8%BF%87%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91)



##### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### ①递归

```java
class Solution {
    HashMap<Integer,Integer> valHashMap=new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i=0;i<inorder.length;i++){
            valHashMap.put(inorder[i],i);
        }
        return build(preorder,0,preorder.length-1,
                    inorder,0,inorder.length-1);
    }

TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
        
    if (preStart > preEnd||postStart>postEnd) {
        return null;
    }

    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // 在中序遍历中定位根节点的位置
    int index = valToIndex.get(rootVal);

    //得出左子树中的节点数目
    int leftSize = index - inStart;

    // 先构造出当前根节点
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, index + 1, inEnd);
    return root;
}

}
```

> 时间复杂度：O*(*n)，其中 *n*是树中的节点个数

###### ②迭代



#### 七、通过后序和中序遍历结果构造二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[从后序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)」

![image-20230713185822619](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131858755.png)

##### <span style="background-color:gold;"><b>思路：</b></span>

> [通过后序和前序遍历结果构造二叉树](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/#通过后序和前序遍历结果构造二叉树)
>
>  根据中序遍历和后续遍历的特性我们进行树的还原过程分析:
>
> 1. 首先在后序遍历序列中找到根节点(最后一个元素)
> 2. 根据根节点在中序遍历序列中找到根节点的位置
> 3. 根据根节点的位置将中序遍历序列分为左子树和右子树
> 4. 根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置
> 5. 递归构造左子树和右子树
> 6. 返回根节点结束
> 7. <img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/8.jpeg" alt="img" style="zoom: 50%;" />
>
> 
>
> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131920871.png" alt="树的还原.png" style="zoom: 25%;" />

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    // 存储 postorder 中值到索引的映射
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for (int i = 0; i < postorder.length; i++) {
            valToIndex.put(postorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    postorder, 0, postorder.length - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] postorder, int postStart, int postEnd) {
        if (preStart > preEnd||postStart>postEnd) {
            return null;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex.get(leftRootVal);
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                postorder, postStart, index);
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                postorder, index + 1, postEnd - 1);

        return root;
    }
}

```

#### 二叉搜索树（Binary Search Tree）

> **BST 的特性：**
>
> 1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。
>
> 2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。
>
> **除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）**。
>
> ```JAVA
> void traverse(TreeNode root) {
>     if (root == null) return;
>     traverse(root.left);
>     // 中序遍历代码位置
>     print(root.val);
>     traverse(root.right);
> }
> ```



##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)」

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307132054734.png" alt="image-20230713205404536" style="zoom: 80%;" />



##### <span style="background-color:gold;"><b>思路：</b></span>

> 此方法并非最优解，根据BSF的性质易得中序遍历能升序输出节点值，因此只需要设置一个递增的判断值就可以找到第k个最小的元素

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
int kthSmallest(TreeNode root, int k) {
    // 利用 BST 的中序遍历特性
    traverse(root, k);
    return res;
}

// 记录结果
int res = 0;
// 记录当前元素的排名
int rank = 0;
void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    /* 中序遍历代码位置 */
    rank++;
    if (k == rank) {
        // 找到第 k 小的元素
        res = root.val;
        return;
    }
    /*****************/
    traverse(root.right, k);
}

```

<span style="background-color:#00FFFF;"><b>题目：</b></span>

[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

<img src="https://labuladong.gitee.io/algo/images/BST1/title1.png" alt="img" style="zoom:50%;" />

<span style="background-color:gold;"><b>思路：</b></span>

> `BST `的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？
>
> **这是不行的。**对于一个节点来说，确实右子树都是比它大的元素，**但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。**
>
> 我们说过，BST 的中序遍历代码可以**升序**打印节点的值，而要计算节点的数值免不了要求和比该节点大的数，既然如此我们只需要**降序**打印节点的值不就能经过所有比某一节点大的数，再设置一个变量来计和然后赋值给根节点，这样不就能达成题目的要求了吗？而想要改变打印顺序只要将遍历顺序改变：先遍历右子树再遍历左子树。

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java

```

