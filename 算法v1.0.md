



# Remember

​																		**随着知识水平的不同，理解随时会变，以自己当时的理解为准。**

## 二叉树

> ### 二叉树的一般解题思路
>
> + 先序遍历（深度优先搜索）
>
> + 中序遍历（深度优先搜索）（尤其二叉搜索树）
>
> + 后序遍历（深度优先搜索）
>
> + 层序遍历（广度优先搜索）（尤其按照层来解决问题的时候）
>
> + 序列化与反序列化（结构唯一性问题）
>
> + 三种遍历图解
>
>   ![img](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131520240.jpeg)
>
>   ![img](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131520375.jpeg)
>
>   

### 递归三部曲

##### ①确定递归函数的参数和返回值

参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode`。

```cpp
public TreeNode invertTree(TreeNode root)
```

##### ②确定终止条件

当前节点为空的时候，就返回

```cpp
    if (root == null) {
        return null;
    }
```

##### ③确定单层递归的逻辑

因为是先前序遍历，先翻转左右子树，然后交换左右子节点。

```cpp
    // 利用函数定义，先翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    // 然后交换左右子节点
    root.left = right;
    root.right = left;
```

基于这递归三步法，代码基本写完，C++代码如下：

```CPP
// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    // 利用函数定义，先翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    // 然后交换左右子节点
    root.left = right;
    root.right = left;

    // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root
    return root;
}
```

### 一、翻转二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

对应题目：力扣第 226 题「[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)」

![image-20230708195200239](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307081952445.png)

##### <span style="background-color:gold;"><b>思路：</b></span>

> 不难发现，只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### 1.遍历的思维

```java
// 主函数
TreeNode invertTree(TreeNode root) {
    // 遍历二叉树，交换每个节点的子节点
    traverse(root);
    return root;
}

// 二叉树遍历函数
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    /**** 前序位置 ****/
    // 每一个节点需要做的事就是交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 遍历框架，去遍历左右子树的节点
    traverse(root.left);
    traverse(root.right);
}
```



###### 2.分解问题的思维（递归）

```java
TreeNode invertTree(TreeNode root)
定义作用：翻转root节点对应的树

利用前序遍历
class Solution {
    // 先序遍历--从顶向下交换
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        
        //逻辑代码：交换左右子树（root的左右节点）
        TreeNode tmp=root.right;
        root.right=root.left;
        root.left=tmp;
        
		//把左、右子树里面的节点进行翻转并赋值给左右子树
        root.right=invertTree(root.right);
        root.left=invertTree(root.left);

        return root;
    }
}

利用中序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
            if (root == null) return null;
        	
        	//先将左子树的节点全部翻转
            invertTree(root.left);
        
        	//逻辑代码：交换左右子树（root的左右节点）
            TreeNode rightNode= root.right; // 保存右节点
            root.right = root.left;
            root.left = rightNode;
        
            // 将右子树的节点进行翻转：因为此时左右节点已经交换了,所以此时的右节点为root.left
            invertTree(root.left); 
        
         return root;
    }
}

利用后序遍历
 class Solution {
        public TreeNode invertTree(TreeNode root) {
            // 后序遍历-- 从下向上交换
            if (root == null) return null;
            
            //把左、右子树里面的节点进行翻转并赋值给左右子树（）
            TreeNode leftNode = invertTree(root.left);
            TreeNode rightNode = invertTree(root.right);
            
            //逻辑代码：交换左右子树（root的左右节点）
            root.right = leftNode;
            root.left = rightNode;
            
            return root;
        }
    }

```

###### 3.层序遍历

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        Queue<TreeNode> q=new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()){
            int size =q.size();
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                
                //逻辑代码：交换左右节点
                TreeNode treeNode=node.right;
                node.right=node.left;
                node.left=treeNode;
                
                if(node.right!=null){
                    q.offer(node.right);
                }
                if(node.left!=null){
                    q.offer(node.left);
                }


            }
        }

        return root;
    }
}
```

### 二、对称二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

[[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)]

![image-20230708210306231](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307082103284.png)



##### <span style="background-color:gold;"><b>思路：</b></span>

> **首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！**
>
> 对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。
>
> 那么如何比较呢？
>
> 比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307082119390.png" alt="20210203144624414" style="zoom:50%;" />
>
> 那么遍历的顺序应该是什么样的呢？
>
> 本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。
>
> **正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**
>
> 其实后序也可以理解为是一种回溯遍历。

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### 1.分解问题（递归）

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left,root.right);
    }
    //1.确定递归函数的参数和返回值
    boolean compare(TreeNode right,TreeNode left){
        
    //2.确定终止条件
        if(right==null&&left==null){//左右都为空，对称，返回true
            return true;
        }else if(right==null&&left!=null){//左节点为空，右节点不为空，不对称，return false
            return false;
        }else if(right!=null&&left==null){//左不为空，右为空，不对称 return false
            return false;
        }else if(left.val!=right.val){//左右都不为空，比较节点数值，不相同就return false
            return false;
        }
    //3.确定单层递归的逻辑
        boolean outside=compare(left.left,right.right);
        boolean inside=compare(left.right,right.left);
        boolean result=outside&&inside;
        return result;
    }

}
```

###### 2.层序遍历（队列）

> 同时遍历两棵树

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {

        Queue<TreeNode> queue=new LinkedList();
        //左右节点
        queue.offer(root.left);
        queue.offer(root.right);
        while(!queue.isEmpty()){
            int size =queue.size();
            for(int i=0;i<size;i++){
                TreeNode left=queue.poll();
                TreeNode right=queue.poll();
                
			
//                if(left==null&&right==null){
//                    continue;
//                }else if(left!=null&&right==null){
//                    return false;
//                }else if(left==null&&right!=null){
//                    return false;
//                }else if(left.val!=right.val){
//                    return false;
//                }
				//代码简化
                if(left==null&&right==null){
                    continue;
                }	                
                if(left==null||right==null||left.val!=right.val){
                    return false;
                }
                //外侧节点先进，里侧节点后进
                queue.offer(left.left);
                queue.offer(right.right);
                queue.offer(left.right);
                queue.offer(right.left);

        }

       
    }
     return true;
}
}
```

### 三、二叉树展开为链表

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[将二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)」

![image-20230709153045864](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091530917.png)



##### <span style="background-color:gold;"><b>思路：</b></span>

> `flatten`:压平
>
> 从该函数的意思上就知道这个函数是用来压平树的，因此定义：**给 `flatten` 函数输入一个节点 `root`，那么以 `root` 为根的二叉树就会被拉平为一条链表**。
>
> 如何利用这个定义来完成算法？你想想怎么把以 `root` 为根的二叉树拉平为一条链表？
>
> 很简单，以下流程：
>
> 1、将 `root` 的左子树和右子树拉平。
>
> 2、将 `root` 的右子树接到左子树下方，然后将整个左子树作为右子树。
>
> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091440174.jpg" alt="2" style="zoom:50%;" />
>
> 至于如何把 `root` 的左右子树拉平，不用你操心，`flatten` 函数的定义就是这样，交给他做就行了。





##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    // 定义：将以 root 为根的树拉平为链表
    public void flatten(TreeNode root) {
        if(root==null){
            return;
        }
		 // 先递归拉平左右子树
        flatten(root.left);
        flatten(root.right);
		
        /****后序遍历位置****/
        // 1、左右子树已经被拉平成一条链表
        TreeNode left=root.left;
        TreeNode tmp=root.right;
		
        // 2、将左子树放到右子树
        root.right=left;
		root.left=null;
        
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode p=root;
        while(p.right!=null){
            p=p.right;
        }
        p.right=tmp;//把捋直的原来的右子树接上去



    }


}
```

### 四、构造最大二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)」

![image-20230709153227590](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091532648.png)



![image-20230709153249507](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091532559.png)





##### <span style="background-color:gold;"><b>思路：</b></span>

> 看完题目中的解释基本上就能看出来有一种浓浓的递归味道在里面，因此我们**考虑递归的方法**来解决。
>
> 构造二叉树**先考虑前序遍历**，先要遍历数组把找到最大值 `max`，从而把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左右子树。



##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums,0,nums.length-1);
    }
    //辅助函数
    TreeNode build(int[] nums,int lo,int hi){
        //终止条件和返回值
        if(lo>hi){
            return null;
        }

        //找到最大值和对应的索引
        int max=Integer.MIN_VALUE,index=-1;//这个两个一定要这样写，不然很容易栈溢出和越界（被上了一课）
        for(int i=lo;i<=hi;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        
        // 先构造出根节点
        TreeNode node=new TreeNode(max);

        //构建左子树
         node.left=build(nums,lo,index-1);
         //构建右子树
         node.right=build(nums,index+1,hi);

        
        return node;


    }
}
```

### 五、通过前序和中序结果构造二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307091747770.png" alt="image-20230709174723674" style="zoom:80%;" />

##### <span style="background-color:gold;"><b>思路：</b></span>

>    每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的当然是把想办法把自己先构造出来，然后想办法构造自己的左右子树。
>
>    所以，我们要遍历数组把找到最大值 `maxVal`，从而把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左右子树。

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums,0,nums.length-1);
    }
    TreeNode build(int[] nums,int lo,int hi){
        //终止条件和返回值
        if(lo>hi){
            return null;
        }

        //找到最大值和对应的索引
        int max=Integer.MIN_VALUE,index=-1;
        for(int i=lo;i<=hi;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        
        //构建中间节点
        TreeNode node=new TreeNode(max);

        //构建左子树
         node.left=build(nums,lo,index-1);
         //构建右子树
         node.right=build(nums,index+1,hi);

        
        return node;


    }
}
```

### 六、通过前序和中序遍历结果构造二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」

![image-20230711220929694](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307112209804.png)

##### <span style="background-color:gold;"><b>思路：</b></span>

> [思路降解](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/#%E9%80%9A%E8%BF%87%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91)



##### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### ①递归

```java
class Solution {
    HashMap<Integer,Integer> valHashMap=new HashMap<>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i=0;i<inorder.length;i++){
            valHashMap.put(inorder[i],i);
        }
        return build(preorder,0,preorder.length-1,
                    inorder,0,inorder.length-1);
    }

TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
        
    if (preStart > preEnd||postStart>postEnd) {
        return null;
    }

    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // 在中序遍历中定位根节点的位置
    int index = valToIndex.get(rootVal);

    //得出左子树中的节点数目
    int leftSize = index - inStart;

    // 先构造出当前根节点
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, index + 1, inEnd);
    return root;
}

}
```

> 时间复杂度：O*(*n)，其中 *n*是树中的节点个数

###### ②迭代



### 七、通过后序和中序遍历结果构造二叉树

##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[从后序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)」

![image-20230713185822619](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131858755.png)

##### <span style="background-color:gold;"><b>思路：</b></span>

> [通过后序和前序遍历结果构造二叉树](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-172f0/#通过后序和前序遍历结果构造二叉树)
>
>  根据中序遍历和后续遍历的特性我们进行树的还原过程分析:
>
> 1. 首先在后序遍历序列中找到根节点(最后一个元素)
> 2. 根据根节点在中序遍历序列中找到根节点的位置
> 3. 根据根节点的位置将中序遍历序列分为左子树和右子树
> 4. 根据根节点的位置确定左子树和右子树在中序数组和后续数组中的左右边界位置
> 5. 递归构造左子树和右子树
> 6. 返回根节点结束
> 7. <img src="https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/8.jpeg" alt="img" style="zoom: 50%;" />
>
> 
>
> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307131920871.png" alt="树的还原.png" style="zoom: 25%;" />

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    // 存储 postorder 中值到索引的映射
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for (int i = 0; i < postorder.length; i++) {
            valToIndex.put(postorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    postorder, 0, postorder.length - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] postorder, int postStart, int postEnd) {
        if (preStart > preEnd||postStart>postEnd) {
            return null;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex.get(leftRootVal);
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                postorder, postStart, index);
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                postorder, index + 1, postEnd - 1);

        return root;
    }
}

```

### 八、二叉搜索树（Binary Search Tree）(特性篇)

> **BST 的特性：**
>
> 1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。
>
> > <span style="background-color:orange ;"><b>注意：</b></span>BST 的每个节点应该要小于右边子树的**所有**节点
>
> 2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。
>
> **除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）**。
>
> ```JAVA
> void traverse(TreeNode root) {
>  if (root == null) return;
>  traverse(root.left);
>  // 中序遍历代码位置
>  print(root.val);
>  traverse(root.right);
> }
> ```



##### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)」

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307132054734.png" alt="image-20230713205404536" style="zoom: 80%;" />



##### <span style="background-color:gold;"><b>思路：</b></span>

> 此方法并非最优解，根据BSF的性质易得中序遍历能升序输出节点值，因此只需要设置一个递增的判断值就可以找到第k个最小的元素

##### <span style="background-color:#a2e043;"><b>题解：</b></span>

```java
int kthSmallest(TreeNode root, int k) {
    // 利用 BST 的中序遍历特性
    traverse(root, k);
    return res;
}

// 记录结果
int res = 0;
// 记录当前元素的排名
int rank = 0;
void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    /* 中序遍历代码位置 */
    rank++;
    if (k == rank) {
        // 找到第 k 小的元素
        res = root.val;
        return;
    }
    /*****************/
    traverse(root.right, k);
}

```

<span style="background-color:#00FFFF;"><b>题目：</b></span>

[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

<img src="https://labuladong.gitee.io/algo/images/BST1/title1.png" alt="img" style="zoom:50%;" />

<span style="background-color:gold;"><b>思路：</b></span>

> `BST `的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？
>
> **这是不行的。**对于一个节点来说，确实右子树都是比它大的元素，**但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。**
>
> 我们说过，BST 的中序遍历代码可以**升序**打印节点的值，而要计算节点的数值免不了要求和比该节点大的数，既然如此我们只需要**降序**打印节点的值不就能经过所有比某一节点大的数，再设置一个变量来计和然后赋值给根节点，这样不就能达成题目的要求了吗？而想要改变打印顺序只要将遍历顺序改变：先遍历右子树再遍历左子树。

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    int sum=0;
    public TreeNode convertBST(TreeNode root) {
        traverse(root);
        return root;
    }

    public void traverse(TreeNode root){
            if(root==null){
                return ;
            }

            traverse(root.right);
        	//对大于root节点的数计和
            sum+=root.val;
        	//赋值
            root.val=sum;
        
            traverse(root.left);

    }


}
```

**重构来去除全局变量：**

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        dfs(root, 0);
        return root;
    }

    private int dfs(TreeNode root, int sum){
        //sum为该节点右边的所有节点的值的总和（所有比该节点大的节点）
        if(root == null){
            return sum;
        }
        //累加操作
        root.val += dfs(root.right, sum);
        //将累加后的结果传递给左边节点
        return dfs(root.left, root.val);
    }
}
```

### 九、二叉搜索树（Binary Search Tree）(基操篇)

##### 1.判断 BST 的合法性

> BST特性：BST 的每个节点应该要小于右边子树的**所有**节点
>
> 下面树便不符合上面的特性：
>
> ![img](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307171137954.png)
>
> **出现的问题是，对于每一个节点 `root`，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，`root` 的整个左子树都要小于 `root.val`，整个右子树都要大于 `root.val`**。

###### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)」

![image-20230717113746318](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307312049271.png)

###### <span style="background-color:gold;"><b>思路：</b></span>

> 由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
>

###### <span style="background-color:#a2e043;"><b>题解：</b></span>

1.递归算法

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
	
    //判断root的val是否是否满足范围
    boolean helper(TreeNode root, long lower,long upper){
        //节点为空，满足
        if(root==null){
            return true;
        }
		//不在边界内部，返回false
        if(root.val<=lower||root.val>=upper){
            return false;
        }
		//对root的左右子树进行判断
        return helper(root.left,lower,root.val)&&helper(root.right,root.val,upper);

    }
}
```

**复杂度分析**

+ 时间复杂度：$O(n)$,其中为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一
  次，因此时间复杂度为$O(m)$。

+ 空间复杂度：$O(n)$,其中为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配
  栈空间，所以这里需要额外的空间且该空问取决于递归的深度，即二叉树的高度。

  最坏情况下二叉树为条链，树的高度为$n$,递归最深达到n层，故最坏情况下空间复杂度为$O(m)$。

2.中序遍历

> <span style="background-color:gold;"><b>思路：</b></span>中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。

```java
class Solution {

    List<Integer> res = new ArrayList<>(); //存储中序遍历的值
  
   public boolean isValidBST(TreeNode root) {
        
        if(root==null){ 
         	return true;   
        }
        
		traverse(root);//中序遍历获取节点值    
        
        for(int i=1;i<res.size();i++){  
            if(res.get(i)<=res.get(i-1))//判断是否有不符合BST要求的 升序排列		
                 return false;   
        }
		return true;//如果所有节点都符合升序,则是有效BST   
    }  

 private void traverse(TreeNode root){
        if(root==null){
            return;
        }    
            traverse(root.left);  
            res.add(root.val);//记录中间节点值  
            traverse(root.right);
    }  
}
```

**复杂度分析**

时间复杂度 O(n):

- 中序遍历需要遍历整棵树,访问每个节点
- traverse() 方法的时间复杂度是O(n),因为它遍历了全树
- isValidBST() 中调用了一次 traverse(),时间复杂度仍然是 O(n)

因此,总的时间复杂度是 O(n)

空间复杂度 O(n):

- 使用了 res 列表存储中序遍历结果
- res 列表的大小取决于二叉树的节点数
- 最坏情况下,二叉树是链表形状,res 列表需要 n 个空间
- traverse() 方法使用了递归,每层递归需要 O(1) 的栈空间
- 递归的最深层次是树的高度 h,最多为 n 层

综上,空间复杂度为 O(n + h) = O(n)

所以时间和空间复杂度都是 O(n)

### 十、在 BST 中搜索元素

#### <span style="background-color:#00FFFF;"><b>题目：</b></span>

「[二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)」

![image-20230720103119514](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307201031869.png)

#### <span style="background-color:gold;"><b>思路：</b></span>

> ​	第一时间想到的是通过遍历判断是否`root.val==target`来寻找节点，
>
> ```java
> TreeNode searchBST(TreeNode root, int target);
>     if (root == null) return null;
>     if (root.val == target) return root;
>     // 当前节点没找到就递归地去左右子树寻找
>     TreeNode left = searchBST(root.left, target);
>     TreeNode right = searchBST(root.right, target);
> 
>     return left != null ? left : right;
> }
> 
> ```
>
> 但这样写其实并没有运用到`BFS`的性质，对于一个已经经过排序数组其实可以用很多方法来查找，这里我们用二分查找的思想

#### <span style="background-color:#a2e043;"><b>题解：</b></span>

###### 1.二分查找（递归）

```java
TreeNode searchBST(TreeNode root, int target) {
    if (root == null) {
        return null;
    }
    // 去左子树搜索
    if (root.val > target) {
        return searchBST(root.left, target);
    }
    // 去右子树搜索
    if (root.val < target) {
        return searchBST(root.right, target);
    }
    return root;

}
···············化简···················
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) return root;
        return root.val < val ? searchBST(root.right, val) : searchBST(root.left, val);
    }
}

```

###### 2.迭代

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while (root != null && root.val != val) {
            root = root.val < val ? root.right : root.left;
        }
        return root;
    }
}
```

###### 方法一：递归

**二叉搜索树满足如下性质：**

+ 左子树所有节点的元素值均小于根的元素值
+ 右子树所有节点的元素值均大于根的元素值。


据此可以得到如下算法：

+ 若root为空则返回空节点；
+ 若val=root.val,则返回root;
+ 若ual<root.val,递归左子树：
+ 若ual>root.wal,递归右子树。

**代码：**

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null) {
            return null;
        }
        if (val == root.val) {
            return root;
        }
        return searchBST(val < root.val ? root.left : root.right, val);
    }
}

```

**复杂度分析：**

+ 时间复杂度：O(N),其中N是二叉搜索树的节点数。最坏情况下二叉搜索树是条链，且要找的元素
  比链未尾的元素值还要小（大），这种情况下我们需要递归N次。
+ 空间复杂度：O(N)。最坏情况下递归需要O(W)的栈空间。

###### **方法二：递归**





### 十一、在 BST 中插入一个数



#### <span style="background-color:gold;"><b>思路：</b></span>

> 向二叉搜索树中插入一个新节点的功能。如果根节点为空，则直接返回一个新节点；否则，根据当前节点的值与插入值的大小关系，递归地在左子树或右子树中继续查找插入位置，直到找到空位置插入新节点.
>
> 如果存在节点的值val等于要插入的val，这段代码会直接跳过插入操作，因为二叉搜索树中一般不会插入已存在的元素。

#### <span style="background-color:#a2e043;"><b>题解：</b></span>

```JAVA
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);
    // if (root.val == val)
    //     BST 中一般不会插入已存在元素
    if (root.val < val) 
        root.right = insertIntoBST(root.right, val);
    if (root.val > val) 
        root.left = insertIntoBST(root.left, val);
    return root;
}
```

### 十二、在 BST 中删除一个数

#### <span style="background-color:gold;"><b>思路：</b></span>

> 这个问题跟插入操作一样都需要先**找**到节点然后进行**改**操作。
>
> 先写一下整体的代码框架：
>
> ```java
> TreeNode deleteNode(TreeNode root, int key) {
>     if (root.val == key) {
>         // 找到啦，进行删除
>     } else if (root.val > key) {
>         // 去左子树找
>         root.left = deleteNode(root.left, key);
>     } else if (root.val < key) {
>         // 去右子树找
>         root.right = deleteNode(root.right, key);
>     }
>     return root;
> }
> 
> ```
>
> 找到节点后共有三种情况：
>
> 1. `A` 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。
>
>      <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307312049680.png" alt="img" style="zoom: 50%;" />
>
>    ```java
>    if (root.left == null && root.right == null)
>        return null;
>    ```
>
> 2. `A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。
>
>     <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307312049025.png" alt="img" style="zoom: 67%;" />
>
>    ```java
>    // 排除了情况 1 之后
>    if (root.left == null) return root.right;
>    if (root.right == null) return root.left;
>    ```
>
> 3. `A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。
>
>     <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307312049803.png" alt="img" style="zoom: 67%;" />
>
>    ```java
>    if (root.left != null && root.right != null) {
>        // 找到右子树的最小节点
>        TreeNode minNode = getMin(root.right);
>        // 把 root 改成 minNode
>        root.val = minNode.val;
>        // 转而去删除 minNode
>        root.right = deleteNode(root.right, minNode.val);
>    }
>    ```
>
>    三种情况分析完毕，填入代码：
>
>    ```java
>    TreeNode deleteNode(TreeNode root, int key) {
>        if (root == null) return null;
>        if (root.val == key) {
>            // 这两个 if 把情况 1 和 2 都正确处理了
>            if (root.left == null) return root.right;
>            if (root.right == null) return root.left;
>            // 处理情况 3
>            // 获得右子树最小的节点
>            TreeNode minNode = getMin(root.right);
>            // 删除右子树最小的节点
>            root.right = deleteNode(root.right, minNode.val);
>            // 用右子树最小的节点替换 root 节点
>            minNode.left = root.left;
>            minNode.right = root.right;
>            root = minNode;
>        } else if (root.val > key) {
>            root.left = deleteNode(root.left, key);
>        } else if (root.val < key) {
>            root.right = deleteNode(root.right, key);
>        }
>        return root;
>    }
>                                                    
>    TreeNode getMin(TreeNode node) {
>        // BST 最左边的就是最小的
>        while (node.left != null) node = node.left;
>        return node;
>    }
>                                                    
>    ```
>
>    这样，删除操作就完成了。注意一下，上述代码在处理情况 3 时通过一系列略微复杂的链表操作交换 `root` 和 `minNode` 两个节点：
>
>    
>
>    ```java
>    // 处理情况 3
>    // 获得右子树最小的节点
>    TreeNode minNode = getMin(root.right);
>    // 删除右子树最小的节点
>    root.right = deleteNode(root.right, minNode.val);
>    // 用右子树最小的节点替换 root 节点
>    minNode.left = root.left;
>    minNode.right = root.right;
>    root = minNode;
>    ```
>
>    有的读者可能会疑惑，替换 `root` 节点为什么这么麻烦，直接改 `val` 字段不就行了？看起来还更简洁易懂：
>
>    
>
>    ```java
>    // 处理情况 3
>    // 获得右子树最小的节点
>    TreeNode minNode = getMin(root.right);
>    // 删除右子树最小的节点
>    root.right = deleteNode(root.right, minNode.val);
>    // 用右子树最小的节点替换 root 节点
>    root.val = minNode.val;
>    ```
>
>    仅对于这道算法题来说是可以的，但这样操作并不完美，我们一般不会通过修改节点内部的值来交换节点。因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。
>
>    最后总结一下吧，通过这篇文章，我们总结出了如下几个技巧：
>
>    1、如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。
>
>    2、在二叉树递归框架之上，扩展出一套 BST 代码框架：
>
>    
>
>    ```java
>    void BST(TreeNode root, int target) {
>        if (root.val == target)
>            // 找到目标，做点什么
>        if (root.val < target) 
>            BST(root.right, target);
>        if (root.val > target)
>            BST(root.left, target);
>    }
>    ```
>
>    3、根据代码框架掌握了 BST 的增删查改操作。



## 二分搜索

​						**二分搜索の诗**

+ **搜索一个元素时，搜索区间两端闭。**
  while条件带等号，否则需要打补丁。
  if相等就返回，其他的事甭操心。
  mid必须加减一，因为区间两端闭。
  while结束就凉了，凄凄惨惨返-1。

+ **搜索左右边界时，搜索区间要阐明。**
  左闭右开最常见，其余逻辑便自明：
  while要用小于号，这样菜能不漏掉。
  if相等别返回，利用mid锁边界。
  mid加一或减一？要看区间开或闭。
  while结束不算完，因为你还没返回。
  索引可能出边界，if检查保平安。

+ **左闭右开最常见，难道常见就合理？**
  labuladong不信邪，偏要改成两端闭。
  搜索区间记于心，或开或闭有何异？
  二分搜索三变体，逻辑统一容易记。
  一套框架改两行，胜过千言和万语。

### 零、二分查找的框架

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}

```

**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

**另外提前说明一下，计算 `mid` 时需要防止溢出**，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大，直接相加导致溢出的情况。

#### 一、寻找一个数（基本的二分搜索）

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 定义target在左闭右闭的区间里，[left, right]
    
    if (target < nums[0] || target > nums[nums.length - 1]) {
        return -1;
    }
    
    while(left <= right) {// 当left==right，区间[left, right]依然有效，所以用 <=
        int mid = left + (right - left) / 2;// 防止溢出 等同于(left + right)/2
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}


    
```

<span style="background-color:gold;"><b>分析：</b></span>

**1、为什么 while 循环的条件中是 <=，而不是 <**？

答：因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`。因为索引大小为 `nums.length` 是越界的，所以我们把 `right` 这一边视为开区间。

我们这个算法中使用的是前者 `[left, right]` 两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```java
    if(nums[mid] == target)
        return mid; 
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 `while(left < right)` 也可以，我们已经知道了出错的原因，就打个补丁好了：



```java
    //...
    while(left < right) {
        // ...
    }
    return nums[left] == target ? left : -1;
```

**2、为什么 `left = mid + 1`，`right = mid - 1`？我看有的代码是 `right = mid` 或者 `left = mid`，没有这些加加减减，到底怎么回事，怎么判断**？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

当然是去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]` 对不对？**因为 `mid` 已经搜索过，应该从搜索区间中去除**。

**3、此算法有什么缺陷**？

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见，**你也许会说，找到一个 `target`，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了**。

#### 二、寻找左侧边界的二分搜索

+ 左开右闭区间

```java
int left_bound(int[] nums, int target) {
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}

```

> [分析：](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-xie-le--3c789/#%E4%BA%8C%E3%80%81%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E8%BE%B9%E7%95%8C%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2)
>
> 因为 `right = nums.length` 而不是 `nums.length - 1`。因此每次循环的「搜索区间」是 `[left, right)` 左闭右开。
>
> `while(left < right)` 终止的条件是 `left == right`，此时搜索区间 `[left, left)` 为空，所以可以正确终止。
>
> **为什么返回 `left` 而不是 `right`**？
>
> 答：都是一样的，因为 while 终止的条件是 `left == right`。

+ 两边都是闭区间

```java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    if(nums.length==0){
        return -1;
    }
    if (target < nums[0] || target > nums[nums.length - 1]) {
        return -1;
    }    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }

    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

```

> 因为要让搜索区间两端都闭，所以 `right` 应该初始化为 `nums.length - 1`，while 的终止条件应该是 `left == right + 1`，也就是其中应该用 `<=`。

#### 三、寻找右侧边界的二分查找

```java
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    if(nums.length==0){
        return -1;
    }
    if (target < nums[0] || target > nums[nums.length - 1]) {
        return -1;
    }    
    while (left <= right) {// 当left==right，区间[left, right]依然有效，所以用 <=
        int mid = left + (right - left) / 2;// 防止溢出 等同于(left + right)/2
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }

    return nums[right] == target ? right : -1;
}

```

> 由于 while 的结束条件为`left+1=right`即   `right == left - 1`，所以你把上述代码中的 `right` 都改成`left+1`也没有问题

#### 四、逻辑统一

第一个，最基本的二分查找算法：

```java
因为我们初始化 right = nums.length - 1
所以决定了我们的「搜索区间」是 [left, right]
所以决定了 while (left <= right)
同时也决定了 left = mid+1 和 right = mid-1

因为我们只需找到一个 target 的索引即可
所以当 nums[mid] == target 时可以立即返回
```

第二个，寻找左侧边界的二分查找：

```java
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid + 1 和 right = mid

因为我们需找到 target 的最左侧索引
所以当 nums[mid] == target 时不要立即返回
而要收紧右侧边界以锁定左侧边界
```

第三个，寻找右侧边界的二分查找：

```java
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid + 1 和 right = mid

因为我们需找到 target 的最右侧索引
所以当 nums[mid] == target 时不要立即返回
而要收紧左侧边界以锁定右侧边界

又因为收紧左侧边界时必须 left = mid + 1
所以最后无论返回 left 还是 right，必须减一
```

对于寻找左右边界的二分搜索，比较常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    if (left < 0 || left >= nums.length) {
        return -1;
    }
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // if (left - 1 < 0 || left - 1 >= nums.length) {
    //     return -1;
    // }
    
    // 由于 while 的结束条件是 right == left - 1，且现在在求右边界
    // 所以用 right 替代 left - 1 更好记
    if (right < 0 || right >= nums.length) {
        return -1;
    }
    return nums[right] == target ? right : -1;
}

```

#### `LeetCode`寻找左右边界

<span style="background-color:#00FFFF;"><b>题目：</b></span>

「[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)」

![image-20230731154101598](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202307312049272.png)

<span style="background-color:gold;"><b>思路：</b></span>

> 通过两次二分查找分别寻找左右边界

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left=findLeftBound(nums,target);
        int right=findRIghtBound(nums,target);
        return new int[] {left, right};
    }

    int findRIghtBound(int[] nums,int target){
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }else if(nums[mid]==target){
                left=mid+1;
            }
        }

            if(right<0||right>=nums.length){
                return -1;
            }

        return nums[right]==target?right:-1; 
    }
    int findLeftBound(int[] nums,int target){
        int left=0,right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target){
                left=mid+1;
            }else if(nums[mid]>target){
                right=mid-1;
            }else if(nums[mid]==target){
                right=mid-1;
            }
        }

            if(left<0||left>=nums.length){
                return -1;
            }

        return nums[left]==target?left:-1; 
    }


}
```



## 链表

#### 一、合并连个<u>有序</u>链表

<span style="background-color:#00FFFF;"><b>题目：</b></span>·

「[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)」

![image-20230802182809347](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308022109004.png)

<span style="background-color:gold;"><b>思路：</b></span>

> 由于题目要求我们合成**有序**的链表，因此合成两个链表时要比较两个节点值的大小，首先创建一个虚拟头结点，并将指针 p 指向该节点。然后分别用指针 p1 和 p2 指向两个链表的头结点。在循环中，比较 p1 和 p2 指向的节点的值，将较小的节点接到 p 指针的后面，并将相应指针前移，直到其中一个指针为空。最后将不为空的链表接到 p 指针的后面。最终返回虚拟头结点的下一个节点，即合并后的链表的头结点。这段代码简单易懂，实现了合并两个有序链表的功能。
>
> 创建了一个虚拟头结点 dummy，并将指针 p 指向该节点。在链表合并过程中，指针 p 会不断地移动到下一个节点。因为第一个节点是虚拟头结点，所以最终合并后的链表的头结点并不是 dummy，而是 dummy 的下一个节点 dummy.next。因此，返回值为 dummy.next。

> **「虚拟头结点」技巧？：**
>
> 「虚拟头结点」技巧是在链表操作中常用的一种技巧，它是在链表头结点之前添加一个节点，该节点不存储任何数据，仅作为链表头结点的前驱节点，用于简化链表的操作。
>
> 在链表算法题中，经常需要对链表进行插入、删除和翻转等操作。如果不使用「虚拟头结点」技巧，在进行这些操作时需要分情况讨论头节点是否需要被修改，增加了代码的复杂度。而使用「虚拟头结点」技巧，可以将所有操作都视为对链表中某个节点的操作，从而简化代码实现。
>
> 例如，在对链表进行插入操作时，如果不使用「虚拟头结点」技巧，需要先判断插入位置是否为链表头节点，如果是，则需要修改头节点指针；否则需要遍历链表找到插入位置并修改前驱节点的指针。而使用「虚拟头结点」技巧，则可以将头节点的前驱节点作为虚拟头结点，无论插入位置是否为头节点，都可以直接进行插入操作，从而简化代码实现。





<span style="background-color:#a2e043;"><b>题解：</b></span>

##### ①解法一

```java
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    // 虚拟头结点
    ListNode dummy = new ListNode(-1), p = dummy;
    ListNode p1 = l1, p2 = l2;
    
    while (p1 != null && p2 != null) {
        // 比较 p1 和 p2 两个指针
        // 将值较小的的节点接到 p 指针
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p 指针不断前进
        p = p.next;
    }
    
    if (p1 != null) {
        p.next = p1;
    }
    
    if (p2 != null) {
        p.next = p2;
    }
    
    return dummy.next;
}

```

> 最后返回的是dummy.next而不是p.next的原因是为了确保返回的是整个合并后的链表的头结点。
>
> 在代码中，我们使用了一个虚拟头结点dummy来简化链表的操作。虚拟头结点的作用是作为合并后链表的头结点的前一个节点，方便在循环中连接节点。
>
> 在循环结束后，p指针会指向合并后链表的最后一个节点的下一个位置，即null。而dummy.next指向的是合并后链表的头结点。所以最后返回dummy.next，即返回合并后链表的头结点。
>
> 如果返回p.next，那么返回的将是合并后链表的最后一个节点的下一个节点，而不是合并后链表的头结点。这样返回的结果将不正确。因此，要返回整个合并后链表的头结点，需要返回dummy.next。

##### ②递归解法



<span style="background-color:gold;"><b>思路：</b></span>

> + 终止条件：当两个链表都为空时，表示我们对链表已合并完成。
> + 如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）
>
> ![QQ202382-213342-HD](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308022152595.gif)

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java
class Solution {
    //函数功能：将传入的链表有序合并成同一个链表并返回链表的头指针
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        else if (l2 == null) {
            return l1;
        }
        else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }
        else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }

    }
}

```

**分析：**

> 关于return L1的个人理解: 递归的核心在于,我只关注我这一层要干什么,返回什么,至于我的下一层(规模减1),我不管,我就是甩手掌柜.
>
> 好,现在我要merge L1,L2.我要怎么做?
>
> - 显然,如果L1空或L2空,我直接返回L1或L2就行,这很好理解.
> - 如果L1第一个元素小于L2的? 那我得把L1的这个元素放到最前面,至于后面的那串长啥样 ,我不管. 我只要接过下级员工干完活后给我的包裹, 然后把我干的活附上去(令L1->next = 这个包裹)就行
> - 这个包裹是下级员工干的活,即merge(L1->next, L2)
>
> 我该返回啥?
>
> - 现在不管我的下一层干了什么,又返回了什么给我, 我只要知道,假设我的工具人们都完成了任务, 那我的任务也就完成了,可以返回最终结果了
> - 最终结果就是我一开始接手的L1头结点+下级员工给我的大包裹,要一并交上去, 这样我的boss才能根据我给它的L1头节点往下找,检查我完成的工作

#### 二、单链表的分解

<span style="background-color:#00FFFF;"><b>题目：</b></span>

「[分隔链表](https://leetcode.cn/problems/partition-list/)」

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308031919036.png" alt="image-20230803004259794" style="zoom: 80%;" />

<span style="background-color:gold;"><b>思路：</b></span>

> 

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java
ListNode partition(ListNode head, int x) {
    // 存放小于 x 的链表的虚拟头结点
    ListNode dummy1 = new ListNode(-1);
    // 存放大于等于 x 的链表的虚拟头结点
    ListNode dummy2 = new ListNode(-1);
    // p1, p2 指针负责生成结果链表
    ListNode p1 = dummy1, p2 = dummy2;
    // p 负责遍历原链表，类似合并两个有序链表的逻辑
    // 这里是将一个链表分解成两个链表
    ListNode p = head;
    while (p != null) {
        if (p.val >= x) {
            p2.next = p;
            p2 = p2.next;
        } else {
            p1.next = p;
            p1 = p1.next;
        }
        // 断开原链表中的每个节点的 next 指针
        ListNode temp = p.next;
        p.next = null;
        p = temp;
    }
    // 连接两个链表
    p1.next = dummy2.next;

    return dummy1.next;
}

```

#### 三、合并 k 个有序链表

<span style="background-color:#00FFFF;"><b>题目：</b></span>

「[合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)」

![image-20230807172411645](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071724773.png)

<span style="background-color:gold;"><b>思路：</b></span>







<span style="background-color:#a2e043;"><b>题解：</b></span>



#### 四、单链表的倒数第 k 个节点

从前往后寻找单链表的第 `k` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 `k` 个节点呢？

那你可能说，假设链表有 `n` 个节点，倒数第 `k` 个节点就是正数第 `n - k + 1` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 `ListNode` 头结点代表一条单链表，你不能直接得出这条链表的长度 `n`，而需要先遍历一遍链表算出 `n` 的值，然后再遍历链表计算第 `n - k + 1` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 `k` 个节点。

那么，我们能不能**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 `k = 2`，思路如下：

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071819063.jpeg" alt="img" style="zoom: 50%;" />

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`：

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071819815.jpeg" alt="img" style="zoom:50%;" />

接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点上：

<img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071820579.jpeg" alt="img" style="zoom:50%;" />

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

上述逻辑的代码如下：

```java
// 返回链表的倒数第 k 个节点
ListNode findFromEnd(ListNode head, int k) {
    ListNode p1 = head;
    // p1 先走 k 步
    for (int i = 0; i < k; i++) {
        p1 = p1.next;
    }
    ListNode p2 = head;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2;
}

```



<span style="background-color:#00FFFF;"><b>题目：</b></span>

「[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)」

![image-20230807183050647](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071830901.png)



<span style="background-color:gold;"><b>思路：</b></span>

> 先找到目标节点的前一个节点也就是第n+1个节点`node`，然后让
>
> ```jade
> node.next=node.next.next;
> ```

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java
// 主函数
public ListNode removeNthFromEnd(ListNode head, int n) {
    // 虚拟头结点
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
    ListNode x = findFromEnd(dummy, n + 1);
    // 删掉倒数第 n 个节点
    x.next = x.next.next;
    return dummy.next;
}
    
private ListNode findFromEnd(ListNode head, int k) {
    
    ListNode p1 = head;
    // p1 先走 k 步
    for (int i = 0; i < k; i++) {
        p1 = p1.next;
    }
    ListNode p2 = head;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2;
}


```

#### 五、单链表的中点

<span style="background-color:#00FFFF;"><b>题目：</b></span>

「[链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)」

![image-20230807183513723](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071835040.png)

<span style="background-color:gold;"><b>思路：</b></span>

> 常规方法也是先遍历链表计算 `n`，再遍历一次得到第 `n / 2` 个节点，也就是中间节点。
>
> 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：
>
> 我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。
>
> **每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

<span style="background-color:#a2e043;"><b>题解：</b></span>

```java
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    //判断fast.next != null是因为循环中的代码有fast = fast.next.next;
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

> 需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。



#### 六、判断链表是否包含环

<span style="background-color:gold;"><b>思路：</b></span>

> 判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：
>
> 每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。
>
> 如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```java
boolean hasCycle(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
        // 快慢指针相遇，说明含有环
        if (slow == fast) {
            return true;
        }
    }
    // 不包含环
    return false;
}

```

<span style="background-color:#00FFFF;"><b>题目：</b></span>

「[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)」

![image-20230807193724015](C:/Users/liukai/AppData/Roaming/Typora/typora-user-images/image-20230807193724015.png)

<span style="background-color:gold;"><b>思路：</b></span>

> **当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。**
>
> 这里简单说一下其中的原理。
>
> 我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：
>
> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071946179.jpeg" alt="img" style="zoom:50%;" />
>
> `fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。
>
> 假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。
>
> 巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：
>
> <img src="https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308071946881.jpeg" alt="img" style="zoom:50%;" />
>
> 所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。





<span style="background-color:#a2e043;"><b>题解：</b></span>

①快慢指针

```java
class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        // 上面的代码类似 hasCycle 函数
        if (fast == null || fast.next == null) {
            // fast 遇到空指针说明没有环
            return null;
        }

        // 重新指向头结点
        slow = head;
        // 快慢指针同步前进，相交点就是环起点
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}

```

②哈希表

```java
public class Solution {   
 
   public ListNode detectCycle(ListNode head) {     
        //[注释]使用Set记录已访问的节点   
        ListNode pos = head;     
        Set<ListNode> visited = new HashSet<ListNode>();   
        
        while (pos != null) {       
           //[注释]如果此节点已访问过,     
           //我们找到了环的开始
          if (visited.contains(pos)) {      
             return pos;   
           }   
          
           //[注释]否则将其标记为已访问    
           else {     
               visited.add(pos);    
           }   
            
             pos = pos.next;
         }     
       
         return null;   
    }
}
```



#### 七、两个链表是否相交



#### 对链表进行插入排序

<span style="background-color:#00FFFF;"><b>题目：</b></span>

[[对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/description/)]

![image-20230819212327349](https://voyager0587.oss-cn-guangzhou.aliyuncs.com/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/202308192123570.png)



<span style="background-color:#a2e043;"><b>题解：</b></span>

##### 解法一

- 想要排序块，就要尽可能少的做比较
- 需要一个指针指向当前已排序的最后一个位置，这里用的是head指针
- 需要另外一个指针pre,每次从表头循环，这里用的是dummy表头指针。
- 每次拿出未排序的节点，先和前驱比较，如果大于或者等于前驱，就不用排序了，直接进入下一次循环
- 如果前驱小，则进入内层循环，依次和pre指针比较，插入对应位置即可。

```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0), pre;
        dummy.next = head;
        //lastSorted是链表的已排序部分的最后一个节点，默认是h
        ListNode lastSorted=head;
        //如果lastSorted后面的节点也是按照排序的顺序的话就将lastSorted后移，直到遇到没有按照顺序的节点
        while(lastSorted != null && lastSorted.next != null) {
            if(lastSorted.val <= lastSorted.next.val) {
                lastSorted = lastSorted.next;
                continue;
            }
            //pre最终是curr插入位置的前一个节点
            pre = dummy;
            //lastSorted.next就是要进行插入操作的节点
            while (pre.next.val < lastSorted.next.val) pre = pre.next;
            //从链表的头节点开始往后遍历链表中的节点，寻找插入 curr 的位置。
            //令 pre 为插入 curr 的位置的前一个节点，进行如下操作，完成对 curr 的插入
            ListNode curr = lastSorted.next;
            lastSorted.next = curr.next;
            curr.next = pre.next;
            pre.next = curr;
        }
        return dummy.next;
    }
}
```

##### 解法二

```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null) {
            return head;
        }
        //便于实现在head前面插入节点
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode lastSorted = head, curr = head.next;
        
        while (curr != null) {
            //如果插入节点curr大于有序链表的最后一个节点，让lastSorted后移一个节点
            if (lastSorted.val <= curr.val) {
                lastSorted = lastSorted.next;
            } else {
                //从链表的头节点开始往后遍历链表中的节点，寻找插入 curr 的位置。
                //令 prev 为插入 curr 的位置的前一个节点，进行如下操作，完成对 curr 的插入
                ListNode prev = dummyHead;
                while (prev.next.val <= curr.val) {
                    prev = prev.next;
                }
                lastSorted.next = curr.next;
                curr.next = prev.next;
                prev.next = curr;
            }
            //待插入节点后移
            curr = lastSorted.next;
        }
        return dummyHead.next;
    }
}

```

#### 冒泡排序

##### ①最基本的冒泡排序

```c++
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);
    bubbleSort(arr, n);
    printf("Sorted array: \n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}

```

##### ②改进版的

> **改进之处：**设置标志位。在每一轮冒泡排序中，我们可以设置一个标志位来记录是否发生了交换操作。如果在一轮排序中没有发生任何交换操作，说明数组已经有序，可以提前结束排序。

```c
void bubbleSort(int arr[], int n) {
    int i, j;
    int flag; // 标志位，用于记录是否发生了交换操作

    for (i = 0; i < n - 1; i++) {
        flag = 1; // 每一轮排序开始时，将标志位设置为true

        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻的元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;

                flag = 0; // 发生交换操作，将标志位设置为false
            }
        }

        // 如果一轮排序中没有发生交换操作，说明数组已经有序，提前结束排序
        if (flag == 1) {
            break;
        }
    }
}
```

















